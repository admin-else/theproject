/*
  This file was generated by mcd2c.py
  It should not be edited by hand
*/

#include <stdlib.h>
#include <string.h>

#include <mc/net/proto.h>

const char *handshaking_toserver_strings[] = {
  "handshaking_toserver_set_protocol",
  "handshaking_toserver_legacy_server_list_ping"
};

const char *status_toclient_strings[] = {
  "status_toclient_server_info",
  "status_toclient_ping"
};

const char *status_toserver_strings[] = {
  "status_toserver_ping_start",
  "status_toserver_ping"
};

const char *login_toclient_strings[] = {
  "login_toclient_disconnect",
  "login_toclient_encryption_begin",
  "login_toclient_success",
  "login_toclient_compress"
};

const char *login_toserver_strings[] = {
  "login_toserver_login_start",
  "login_toserver_encryption_begin"
};

const char *play_toclient_strings[] = {
  "play_toclient_keep_alive",
  "play_toclient_login",
  "play_toclient_chat",
  "play_toclient_update_time",
  "play_toclient_entity_equipment",
  "play_toclient_spawn_position",
  "play_toclient_update_health",
  "play_toclient_respawn",
  "play_toclient_position",
  "play_toclient_held_item_slot",
  "play_toclient_bed",
  "play_toclient_animation",
  "play_toclient_named_entity_spawn",
  "play_toclient_collect",
  "play_toclient_spawn_entity",
  "play_toclient_spawn_entity_living",
  "play_toclient_spawn_entity_painting",
  "play_toclient_spawn_entity_experience_orb",
  "play_toclient_entity_velocity",
  "play_toclient_entity_destroy",
  "play_toclient_entity",
  "play_toclient_rel_entity_move",
  "play_toclient_entity_look",
  "play_toclient_entity_move_look",
  "play_toclient_entity_teleport",
  "play_toclient_entity_head_rotation",
  "play_toclient_entity_status",
  "play_toclient_attach_entity",
  "play_toclient_entity_metadata",
  "play_toclient_entity_effect",
  "play_toclient_remove_entity_effect",
  "play_toclient_experience",
  "play_toclient_update_attributes",
  "play_toclient_map_chunk",
  "play_toclient_multi_block_change",
  "play_toclient_block_change",
  "play_toclient_block_action",
  "play_toclient_block_break_animation",
  "play_toclient_map_chunk_bulk",
  "play_toclient_explosion",
  "play_toclient_world_event",
  "play_toclient_named_sound_effect",
  "play_toclient_world_particles",
  "play_toclient_game_state_change",
  "play_toclient_spawn_entity_weather",
  "play_toclient_open_window",
  "play_toclient_close_window",
  "play_toclient_set_slot",
  "play_toclient_window_items",
  "play_toclient_craft_progress_bar",
  "play_toclient_transaction",
  "play_toclient_update_sign",
  "play_toclient_map",
  "play_toclient_tile_entity_data",
  "play_toclient_open_sign_entity",
  "play_toclient_statistics",
  "play_toclient_player_info",
  "play_toclient_abilities",
  "play_toclient_tab_complete",
  "play_toclient_scoreboard_objective",
  "play_toclient_scoreboard_score",
  "play_toclient_scoreboard_display_objective",
  "play_toclient_scoreboard_team",
  "play_toclient_custom_payload",
  "play_toclient_kick_disconnect",
  "play_toclient_difficulty",
  "play_toclient_combat_event",
  "play_toclient_camera",
  "play_toclient_world_border",
  "play_toclient_title",
  "play_toclient_set_compression",
  "play_toclient_playerlist_header",
  "play_toclient_resource_pack_send",
  "play_toclient_update_entity_nbt"
};

const char *play_toserver_strings[] = {
  "play_toserver_keep_alive",
  "play_toserver_chat",
  "play_toserver_use_entity",
  "play_toserver_flying",
  "play_toserver_position",
  "play_toserver_look",
  "play_toserver_position_look",
  "play_toserver_block_dig",
  "play_toserver_block_place",
  "play_toserver_held_item_slot",
  "play_toserver_arm_animation",
  "play_toserver_entity_action",
  "play_toserver_steer_vehicle",
  "play_toserver_close_window",
  "play_toserver_window_click",
  "play_toserver_transaction",
  "play_toserver_set_creative_slot",
  "play_toserver_enchant_item",
  "play_toserver_update_sign",
  "play_toserver_abilities",
  "play_toserver_tab_complete",
  "play_toserver_settings",
  "play_toserver_client_command",
  "play_toserver_custom_payload",
  "play_toserver_spectate",
  "play_toserver_resource_pack_receive"
};

const char **protocol_strings[protocol_state_max][protocol_direction_max] = {
  [handshaking_id][toserver_id] = handshaking_toserver_strings,
  [status_id][toclient_id] = status_toclient_strings,
  [status_id][toserver_id] = status_toserver_strings,
  [login_id][toclient_id] = login_toclient_strings,
  [login_id][toserver_id] = login_toserver_strings,
  [play_id][toclient_id] = play_toclient_strings,
  [play_id][toserver_id] = play_toserver_strings
};

const int protocol_max_ids[protocol_state_max][protocol_direction_max] = {
  [handshaking_id][toclient_id] = handshaking_toclient_max,
  [handshaking_id][toserver_id] = handshaking_toserver_max,
  [status_id][toclient_id] = status_toclient_max,
  [status_id][toserver_id] = status_toserver_max,
  [login_id][toclient_id] = login_toclient_max,
  [login_id][toserver_id] = login_toserver_max,
  [play_id][toclient_id] = play_toclient_max,
  [play_id][toserver_id] = play_toserver_max
};

int walk_handshaking_toserver_set_protocol(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if((ret = walk_string(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if(max_len < 2) {
    return -1;
  }
  size += 2;
  source += 2;
  max_len -= 2;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  return size + ret;
}

size_t size_handshaking_toserver_set_protocol(handshaking_toserver_set_protocol packet) {
  size_t size = 0;
  size += size_varlong(packet.protocol_version);
  size += size_string(packet.server_host);
  size += 2;
  size += size_varlong(packet.next_state);
  return size;
}

char * dec_handshaking_toserver_set_protocol(handshaking_toserver_set_protocol *packet, char * source) {
  source = dec_varlong(&packet->protocol_version, source);
  if(!(source = dec_string(&packet->server_host, source))) return NULL;
  source = dec_be16(&packet->server_port, source);
  source = dec_varlong(&packet->next_state, source);
  return source;
}

char * enc_handshaking_toserver_set_protocol(char * dest, handshaking_toserver_set_protocol source) {
  dest = enc_varlong(dest, source.protocol_version);
  dest = enc_string(dest, source.server_host);
  dest = enc_be16(dest, source.server_port);
  dest = enc_varlong(dest, source.next_state);
  return dest;
}

void free_handshaking_toserver_set_protocol(handshaking_toserver_set_protocol packet) {
  free_string(packet.server_host);
}

int walk_handshaking_toserver_legacy_server_list_ping(char * source, size_t max_len) {
  if(max_len < 1) return -1;
  return 1;
}

size_t size_handshaking_toserver_legacy_server_list_ping(handshaking_toserver_legacy_server_list_ping packet) {
  return 1;
}

char * dec_handshaking_toserver_legacy_server_list_ping(handshaking_toserver_legacy_server_list_ping *packet, char * source) {
  source = dec_byte(&packet->payload, source);
  return source;
}

char * enc_handshaking_toserver_legacy_server_list_ping(char * dest, handshaking_toserver_legacy_server_list_ping source) {
  dest = enc_byte(dest, source.payload);
  return dest;
}

int walk_status_toclient_server_info(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_string(source, max_len)) < 0) {
    return -1;
  }
  return size + ret;
}

size_t size_status_toclient_server_info(status_toclient_server_info packet) {
  size_t size = 0;
  size += size_string(packet.response);
  return size;
}

char * dec_status_toclient_server_info(status_toclient_server_info *packet, char * source) {
  if(!(source = dec_string(&packet->response, source))) return NULL;
  return source;
}

char * enc_status_toclient_server_info(char * dest, status_toclient_server_info source) {
  dest = enc_string(dest, source.response);
  return dest;
}

void free_status_toclient_server_info(status_toclient_server_info packet) {
  free_string(packet.response);
}

int walk_status_toclient_ping(char * source, size_t max_len) {
  if(max_len < 8) return -1;
  return 8;
}

size_t size_status_toclient_ping(status_toclient_ping packet) {
  return 8;
}

char * dec_status_toclient_ping(status_toclient_ping *packet, char * source) {
  source = dec_be64(&packet->time, source);
  return source;
}

char * enc_status_toclient_ping(char * dest, status_toclient_ping source) {
  dest = enc_be64(dest, source.time);
  return dest;
}

int walk_status_toserver_ping(char * source, size_t max_len) {
  if(max_len < 8) return -1;
  return 8;
}

size_t size_status_toserver_ping(status_toserver_ping packet) {
  return 8;
}

char * dec_status_toserver_ping(status_toserver_ping *packet, char * source) {
  source = dec_be64(&packet->time, source);
  return source;
}

char * enc_status_toserver_ping(char * dest, status_toserver_ping source) {
  dest = enc_be64(dest, source.time);
  return dest;
}

int walk_login_toclient_disconnect(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_string(source, max_len)) < 0) {
    return -1;
  }
  return size + ret;
}

size_t size_login_toclient_disconnect(login_toclient_disconnect packet) {
  size_t size = 0;
  size += size_string(packet.reason);
  return size;
}

char * dec_login_toclient_disconnect(login_toclient_disconnect *packet, char * source) {
  if(!(source = dec_string(&packet->reason, source))) return NULL;
  return source;
}

char * enc_login_toclient_disconnect(char * dest, login_toclient_disconnect source) {
  dest = enc_string(dest, source.reason);
  return dest;
}

void free_login_toclient_disconnect(login_toclient_disconnect packet) {
  free_string(packet.reason);
}

int walk_login_toclient_encryption_begin(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_string(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  max_len -= ret;
  int64_t public_key_len;
  source = dec_varlong(&public_key_len, source);
  if(max_len < public_key_len) {
    return -1;
  }
  size += public_key_len;
  source += public_key_len;
  max_len -= public_key_len;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  max_len -= ret;
  int64_t verify_token_len;
  source = dec_varlong(&verify_token_len, source);
  if(max_len < verify_token_len) {
    return -1;
  }
  size += verify_token_len;
  source += verify_token_len;
  max_len -= verify_token_len;
  return size;
}

size_t size_login_toclient_encryption_begin(login_toclient_encryption_begin packet) {
  size_t size = 0;
  size += size_string(packet.server_id);
  size += size_varlong(packet.public_key.len);
  size += packet.public_key.len;
  size += size_varlong(packet.verify_token.len);
  size += packet.verify_token.len;
  return size;
}

char * dec_login_toclient_encryption_begin(login_toclient_encryption_begin *packet, char * source) {
  if(!(source = dec_string(&packet->server_id, source))) return NULL;
  source = dec_varlong(&packet->public_key.len, source);
  if(!(packet->public_key.base = malloc(packet->public_key.len))) return NULL;
  memcpy(packet->public_key.base, source, packet->public_key.len);
  source += packet->public_key.len;
  source = dec_varlong(&packet->verify_token.len, source);
  if(!(packet->verify_token.base = malloc(packet->verify_token.len))) return NULL;
  memcpy(packet->verify_token.base, source, packet->verify_token.len);
  source += packet->verify_token.len;
  return source;
}

char * enc_login_toclient_encryption_begin(char * dest, login_toclient_encryption_begin source) {
  dest = enc_string(dest, source.server_id);
  dest = enc_varlong(dest, source.public_key.len);
  dest = memcpy(dest, source.public_key.base, source.public_key.len);
  dest = enc_varlong(dest, source.verify_token.len);
  dest = memcpy(dest, source.verify_token.base, source.verify_token.len);
  return dest;
}

void free_login_toclient_encryption_begin(login_toclient_encryption_begin packet) {
  free_string(packet.server_id);
  free(packet.public_key.base);
  free(packet.verify_token.base);
}

int walk_login_toclient_success(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_string(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if((ret = walk_string(source, max_len)) < 0) {
    return -1;
  }
  return size + ret;
}

size_t size_login_toclient_success(login_toclient_success packet) {
  size_t size = 0;
  size += size_string(packet.uuid);
  size += size_string(packet.username);
  return size;
}

char * dec_login_toclient_success(login_toclient_success *packet, char * source) {
  if(!(source = dec_string(&packet->uuid, source))) return NULL;
  if(!(source = dec_string(&packet->username, source))) return NULL;
  return source;
}

char * enc_login_toclient_success(char * dest, login_toclient_success source) {
  dest = enc_string(dest, source.uuid);
  dest = enc_string(dest, source.username);
  return dest;
}

void free_login_toclient_success(login_toclient_success packet) {
  free_string(packet.uuid);
  free_string(packet.username);
}

int walk_login_toclient_compress(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  return size + ret;
}

size_t size_login_toclient_compress(login_toclient_compress packet) {
  size_t size = 0;
  size += size_varlong(packet.threshold);
  return size;
}

char * dec_login_toclient_compress(login_toclient_compress *packet, char * source) {
  source = dec_varlong(&packet->threshold, source);
  return source;
}

char * enc_login_toclient_compress(char * dest, login_toclient_compress source) {
  dest = enc_varlong(dest, source.threshold);
  return dest;
}

int walk_login_toserver_login_start(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_string(source, max_len)) < 0) {
    return -1;
  }
  return size + ret;
}

size_t size_login_toserver_login_start(login_toserver_login_start packet) {
  size_t size = 0;
  size += size_string(packet.username);
  return size;
}

char * dec_login_toserver_login_start(login_toserver_login_start *packet, char * source) {
  if(!(source = dec_string(&packet->username, source))) return NULL;
  return source;
}

char * enc_login_toserver_login_start(char * dest, login_toserver_login_start source) {
  dest = enc_string(dest, source.username);
  return dest;
}

void free_login_toserver_login_start(login_toserver_login_start packet) {
  free_string(packet.username);
}

int walk_login_toserver_encryption_begin(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  max_len -= ret;
  int64_t shared_secret_len;
  source = dec_varlong(&shared_secret_len, source);
  if(max_len < shared_secret_len) {
    return -1;
  }
  size += shared_secret_len;
  source += shared_secret_len;
  max_len -= shared_secret_len;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  max_len -= ret;
  int64_t verify_token_len;
  source = dec_varlong(&verify_token_len, source);
  if(max_len < verify_token_len) {
    return -1;
  }
  size += verify_token_len;
  source += verify_token_len;
  max_len -= verify_token_len;
  return size;
}

size_t size_login_toserver_encryption_begin(login_toserver_encryption_begin packet) {
  size_t size = 0;
  size += size_varlong(packet.shared_secret.len);
  size += packet.shared_secret.len;
  size += size_varlong(packet.verify_token.len);
  size += packet.verify_token.len;
  return size;
}

char * dec_login_toserver_encryption_begin(login_toserver_encryption_begin *packet, char * source) {
  source = dec_varlong(&packet->shared_secret.len, source);
  if(!(packet->shared_secret.base = malloc(packet->shared_secret.len))) return NULL;
  memcpy(packet->shared_secret.base, source, packet->shared_secret.len);
  source += packet->shared_secret.len;
  source = dec_varlong(&packet->verify_token.len, source);
  if(!(packet->verify_token.base = malloc(packet->verify_token.len))) return NULL;
  memcpy(packet->verify_token.base, source, packet->verify_token.len);
  source += packet->verify_token.len;
  return source;
}

char * enc_login_toserver_encryption_begin(char * dest, login_toserver_encryption_begin source) {
  dest = enc_varlong(dest, source.shared_secret.len);
  dest = memcpy(dest, source.shared_secret.base, source.shared_secret.len);
  dest = enc_varlong(dest, source.verify_token.len);
  dest = memcpy(dest, source.verify_token.base, source.verify_token.len);
  return dest;
}

void free_login_toserver_encryption_begin(login_toserver_encryption_begin packet) {
  free(packet.shared_secret.base);
  free(packet.verify_token.base);
}

int walk_play_toclient_keep_alive(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  return size + ret;
}

size_t size_play_toclient_keep_alive(play_toclient_keep_alive packet) {
  size_t size = 0;
  size += size_varlong(packet.keep_alive_id);
  return size;
}

char * dec_play_toclient_keep_alive(play_toclient_keep_alive *packet, char * source) {
  source = dec_varlong(&packet->keep_alive_id, source);
  return source;
}

char * enc_play_toclient_keep_alive(char * dest, play_toclient_keep_alive source) {
  dest = enc_varlong(dest, source.keep_alive_id);
  return dest;
}

int walk_play_toclient_login(char * source, size_t max_len) {
  int ret, size = 0;
  if(max_len < 8) {
    return -1;
  }
  size += 8;
  source += 8;
  max_len -= 8;
  if((ret = walk_string(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if(max_len < 1) {
    return -1;
  }
  return size + 1;
}

size_t size_play_toclient_login(play_toclient_login packet) {
  size_t size = 0;
  size += 8;
  size += size_string(packet.level_type);
  return size + 1;
}

char * dec_play_toclient_login(play_toclient_login *packet, char * source) {
  source = dec_be32(&packet->entity_id, source);
  source = dec_byte(&packet->game_mode, source);
  source = dec_byte(&packet->dimension, source);
  source = dec_byte(&packet->difficulty, source);
  source = dec_byte(&packet->max_players, source);
  if(!(source = dec_string(&packet->level_type, source))) return NULL;
  source = dec_byte(&packet->reduced_debug_info, source);
  return source;
}

char * enc_play_toclient_login(char * dest, play_toclient_login source) {
  dest = enc_be32(dest, source.entity_id);
  dest = enc_byte(dest, source.game_mode);
  dest = enc_byte(dest, source.dimension);
  dest = enc_byte(dest, source.difficulty);
  dest = enc_byte(dest, source.max_players);
  dest = enc_string(dest, source.level_type);
  dest = enc_byte(dest, source.reduced_debug_info);
  return dest;
}

void free_play_toclient_login(play_toclient_login packet) {
  free_string(packet.level_type);
}

int walk_play_toclient_chat(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_string(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if(max_len < 1) {
    return -1;
  }
  return size + 1;
}

size_t size_play_toclient_chat(play_toclient_chat packet) {
  size_t size = 0;
  size += size_string(packet.message);
  return size + 1;
}

char * dec_play_toclient_chat(play_toclient_chat *packet, char * source) {
  if(!(source = dec_string(&packet->message, source))) return NULL;
  source = dec_byte(&packet->position, source);
  return source;
}

char * enc_play_toclient_chat(char * dest, play_toclient_chat source) {
  dest = enc_string(dest, source.message);
  dest = enc_byte(dest, source.position);
  return dest;
}

void free_play_toclient_chat(play_toclient_chat packet) {
  free_string(packet.message);
}

int walk_play_toclient_update_time(char * source, size_t max_len) {
  if(max_len < 16) return -1;
  return 16;
}

size_t size_play_toclient_update_time(play_toclient_update_time packet) {
  return 16;
}

char * dec_play_toclient_update_time(play_toclient_update_time *packet, char * source) {
  source = dec_be64(&packet->age, source);
  source = dec_be64(&packet->time, source);
  return source;
}

char * enc_play_toclient_update_time(char * dest, play_toclient_update_time source) {
  dest = enc_be64(dest, source.age);
  dest = enc_be64(dest, source.time);
  return dest;
}

int walk_play_toclient_entity_equipment(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if(max_len < 2) {
    return -1;
  }
  size += 2;
  source += 2;
  max_len -= 2;
  if((ret = walk_slot(source, max_len)) < 0) {
    return -1;
  }
  return size + ret;
}

size_t size_play_toclient_entity_equipment(play_toclient_entity_equipment packet) {
  size_t size = 0;
  size += size_varlong(packet.entity_id);
  size += 2;
  size += size_slot(packet.item);
  return size;
}

char * dec_play_toclient_entity_equipment(play_toclient_entity_equipment *packet, char * source) {
  source = dec_varlong(&packet->entity_id, source);
  source = dec_be16(&packet->slot, source);
  if(!(source = dec_slot(&packet->item, source))) return NULL;
  return source;
}

char * enc_play_toclient_entity_equipment(char * dest, play_toclient_entity_equipment source) {
  dest = enc_varlong(dest, source.entity_id);
  dest = enc_be16(dest, source.slot);
  dest = enc_slot(dest, source.item);
  return dest;
}

void free_play_toclient_entity_equipment(play_toclient_entity_equipment packet) {
  free_slot(packet.item);
}

int walk_play_toclient_spawn_position(char * source, size_t max_len) {
  if(max_len < 8) return -1;
  return 8;
}

size_t size_play_toclient_spawn_position(play_toclient_spawn_position packet) {
  return 8;
}

char * dec_play_toclient_spawn_position(play_toclient_spawn_position *packet, char * source) {
  source = dec_position(&packet->location, source);
  return source;
}

char * enc_play_toclient_spawn_position(char * dest, play_toclient_spawn_position source) {
  dest = enc_position(dest, source.location);
  return dest;
}

int walk_play_toclient_update_health(char * source, size_t max_len) {
  int ret, size = 0;
  if(max_len < 4) {
    return -1;
  }
  size += 4;
  source += 4;
  max_len -= 4;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if(max_len < 4) {
    return -1;
  }
  return size + 4;
}

size_t size_play_toclient_update_health(play_toclient_update_health packet) {
  size_t size = 0;
  size += 4;
  size += size_varlong(packet.food);
  return size + 4;
}

char * dec_play_toclient_update_health(play_toclient_update_health *packet, char * source) {
  source = dec_bef32(&packet->health, source);
  source = dec_varlong(&packet->food, source);
  source = dec_bef32(&packet->food_saturation, source);
  return source;
}

char * enc_play_toclient_update_health(char * dest, play_toclient_update_health source) {
  dest = enc_bef32(dest, source.health);
  dest = enc_varlong(dest, source.food);
  dest = enc_bef32(dest, source.food_saturation);
  return dest;
}

int walk_play_toclient_respawn(char * source, size_t max_len) {
  int ret, size = 0;
  if(max_len < 6) {
    return -1;
  }
  size += 6;
  source += 6;
  max_len -= 6;
  if((ret = walk_string(source, max_len)) < 0) {
    return -1;
  }
  return size + ret;
}

size_t size_play_toclient_respawn(play_toclient_respawn packet) {
  size_t size = 0;
  size += 6;
  size += size_string(packet.level_type);
  return size;
}

char * dec_play_toclient_respawn(play_toclient_respawn *packet, char * source) {
  source = dec_be32(&packet->dimension, source);
  source = dec_byte(&packet->difficulty, source);
  source = dec_byte(&packet->gamemode, source);
  if(!(source = dec_string(&packet->level_type, source))) return NULL;
  return source;
}

char * enc_play_toclient_respawn(char * dest, play_toclient_respawn source) {
  dest = enc_be32(dest, source.dimension);
  dest = enc_byte(dest, source.difficulty);
  dest = enc_byte(dest, source.gamemode);
  dest = enc_string(dest, source.level_type);
  return dest;
}

void free_play_toclient_respawn(play_toclient_respawn packet) {
  free_string(packet.level_type);
}

int walk_play_toclient_position(char * source, size_t max_len) {
  if(max_len < 33) return -1;
  return 33;
}

size_t size_play_toclient_position(play_toclient_position packet) {
  return 33;
}

char * dec_play_toclient_position(play_toclient_position *packet, char * source) {
  source = dec_bef64(&packet->x, source);
  source = dec_bef64(&packet->y, source);
  source = dec_bef64(&packet->z, source);
  source = dec_bef32(&packet->yaw, source);
  source = dec_bef32(&packet->pitch, source);
  source = dec_byte(&packet->flags, source);
  return source;
}

char * enc_play_toclient_position(char * dest, play_toclient_position source) {
  dest = enc_bef64(dest, source.x);
  dest = enc_bef64(dest, source.y);
  dest = enc_bef64(dest, source.z);
  dest = enc_bef32(dest, source.yaw);
  dest = enc_bef32(dest, source.pitch);
  dest = enc_byte(dest, source.flags);
  return dest;
}

int walk_play_toclient_held_item_slot(char * source, size_t max_len) {
  if(max_len < 1) return -1;
  return 1;
}

size_t size_play_toclient_held_item_slot(play_toclient_held_item_slot packet) {
  return 1;
}

char * dec_play_toclient_held_item_slot(play_toclient_held_item_slot *packet, char * source) {
  source = dec_byte(&packet->slot, source);
  return source;
}

char * enc_play_toclient_held_item_slot(char * dest, play_toclient_held_item_slot source) {
  dest = enc_byte(dest, source.slot);
  return dest;
}

int walk_play_toclient_bed(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if(max_len < 8) {
    return -1;
  }
  return size + 8;
}

size_t size_play_toclient_bed(play_toclient_bed packet) {
  size_t size = 0;
  size += size_varlong(packet.entity_id);
  return size + 8;
}

char * dec_play_toclient_bed(play_toclient_bed *packet, char * source) {
  source = dec_varlong(&packet->entity_id, source);
  source = dec_position(&packet->location, source);
  return source;
}

char * enc_play_toclient_bed(char * dest, play_toclient_bed source) {
  dest = enc_varlong(dest, source.entity_id);
  dest = enc_position(dest, source.location);
  return dest;
}

int walk_play_toclient_animation(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if(max_len < 1) {
    return -1;
  }
  return size + 1;
}

size_t size_play_toclient_animation(play_toclient_animation packet) {
  size_t size = 0;
  size += size_varlong(packet.entity_id);
  return size + 1;
}

char * dec_play_toclient_animation(play_toclient_animation *packet, char * source) {
  source = dec_varlong(&packet->entity_id, source);
  source = dec_byte(&packet->animation, source);
  return source;
}

char * enc_play_toclient_animation(char * dest, play_toclient_animation source) {
  dest = enc_varlong(dest, source.entity_id);
  dest = enc_byte(dest, source.animation);
  return dest;
}

int walk_play_toclient_named_entity_spawn(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if(max_len < 32) {
    return -1;
  }
  size += 32;
  source += 32;
  max_len -= 32;
  if((ret = walk_metadata(source, max_len)) < 0) {
    return -1;
  }
  return size + ret;
}

size_t size_play_toclient_named_entity_spawn(play_toclient_named_entity_spawn packet) {
  size_t size = 0;
  size += size_varlong(packet.entity_id);
  size += 32;
  size += size_metadata(packet.metadata);
  return size;
}

char * dec_play_toclient_named_entity_spawn(play_toclient_named_entity_spawn *packet, char * source) {
  source = dec_varlong(&packet->entity_id, source);
  source = dec_uuid(&packet->player_uuid, source);
  source = dec_be32(&packet->x, source);
  source = dec_be32(&packet->y, source);
  source = dec_be32(&packet->z, source);
  source = dec_byte(&packet->yaw, source);
  source = dec_byte(&packet->pitch, source);
  source = dec_be16(&packet->current_item, source);
  if(!(source = dec_metadata(&packet->metadata, source))) return NULL;
  return source;
}

char * enc_play_toclient_named_entity_spawn(char * dest, play_toclient_named_entity_spawn source) {
  dest = enc_varlong(dest, source.entity_id);
  dest = enc_uuid(dest, source.player_uuid);
  dest = enc_be32(dest, source.x);
  dest = enc_be32(dest, source.y);
  dest = enc_be32(dest, source.z);
  dest = enc_byte(dest, source.yaw);
  dest = enc_byte(dest, source.pitch);
  dest = enc_be16(dest, source.current_item);
  dest = enc_metadata(dest, source.metadata);
  return dest;
}

void free_play_toclient_named_entity_spawn(play_toclient_named_entity_spawn packet) {
  free_metadata(packet.metadata);
}

int walk_play_toclient_collect(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  return size + ret;
}

size_t size_play_toclient_collect(play_toclient_collect packet) {
  size_t size = 0;
  size += size_varlong(packet.collected_entity_id);
  size += size_varlong(packet.collector_entity_id);
  return size;
}

char * dec_play_toclient_collect(play_toclient_collect *packet, char * source) {
  source = dec_varlong(&packet->collected_entity_id, source);
  source = dec_varlong(&packet->collector_entity_id, source);
  return source;
}

char * enc_play_toclient_collect(char * dest, play_toclient_collect source) {
  dest = enc_varlong(dest, source.collected_entity_id);
  dest = enc_varlong(dest, source.collector_entity_id);
  return dest;
}

int walk_play_toclient_spawn_entity(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if(max_len < 15) {
    return -1;
  }
  size += 15;
  source += 15;
  max_len -= 15;
  int32_t int_field;
  if(max_len < 4) {
    return -1;
  }
  size += 4;
  max_len -= 4;
  source = dec_be32(&int_field, source);
  switch(int_field) {
    case 0:
      // void condition
      break;
    default:
      if(max_len < 2) {
        return -1;
      }
      size += 2;
      source += 2;
      max_len -= 2;
  }
  switch(int_field) {
    case 0:
      // void condition
      break;
    default:
      if(max_len < 2) {
        return -1;
      }
      size += 2;
      source += 2;
      max_len -= 2;
  }
  switch(int_field) {
    case 0:
      // void condition
      break;
    default:
      if(max_len < 2) {
        return -1;
      }
      size += 2;
      source += 2;
      max_len -= 2;
  }
  return size;
}

size_t size_play_toclient_spawn_entity(play_toclient_spawn_entity packet) {
  size_t size = 0;
  size += size_varlong(packet.entity_id);
  size += 15;
  size += 4;
  switch(packet.object_data.int_field) {
    case 0:
      // void condition
      break;
    default:
      size += 2;
  }
  switch(packet.object_data.int_field) {
    case 0:
      // void condition
      break;
    default:
      size += 2;
  }
  switch(packet.object_data.int_field) {
    case 0:
      // void condition
      break;
    default:
      size += 2;
  }
  return size;
}

char * dec_play_toclient_spawn_entity(play_toclient_spawn_entity *packet, char * source) {
  source = dec_varlong(&packet->entity_id, source);
  source = dec_byte(&packet->type, source);
  source = dec_be32(&packet->x, source);
  source = dec_be32(&packet->y, source);
  source = dec_be32(&packet->z, source);
  source = dec_byte(&packet->pitch, source);
  source = dec_byte(&packet->yaw, source);
  source = dec_be32(&packet->object_data.int_field, source);
  switch(packet->object_data.int_field) {
    case 0:
      // void condition
      break;
    default:
      source = dec_be16(&packet->object_data.velocity_x, source);
  }
  switch(packet->object_data.int_field) {
    case 0:
      // void condition
      break;
    default:
      source = dec_be16(&packet->object_data.velocity_y, source);
  }
  switch(packet->object_data.int_field) {
    case 0:
      // void condition
      break;
    default:
      source = dec_be16(&packet->object_data.velocity_z, source);
  }
  return source;
}

char * enc_play_toclient_spawn_entity(char * dest, play_toclient_spawn_entity source) {
  dest = enc_varlong(dest, source.entity_id);
  dest = enc_byte(dest, source.type);
  dest = enc_be32(dest, source.x);
  dest = enc_be32(dest, source.y);
  dest = enc_be32(dest, source.z);
  dest = enc_byte(dest, source.pitch);
  dest = enc_byte(dest, source.yaw);
  dest = enc_be32(dest, source.object_data.int_field);
  switch(source.object_data.int_field) {
    case 0:
      // void condition
      break;
    default:
      dest = enc_be16(dest, source.object_data.velocity_x);
  }
  switch(source.object_data.int_field) {
    case 0:
      // void condition
      break;
    default:
      dest = enc_be16(dest, source.object_data.velocity_y);
  }
  switch(source.object_data.int_field) {
    case 0:
      // void condition
      break;
    default:
      dest = enc_be16(dest, source.object_data.velocity_z);
  }
  return dest;
}

int walk_play_toclient_spawn_entity_living(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if(max_len < 22) {
    return -1;
  }
  size += 22;
  source += 22;
  max_len -= 22;
  if((ret = walk_metadata(source, max_len)) < 0) {
    return -1;
  }
  return size + ret;
}

size_t size_play_toclient_spawn_entity_living(play_toclient_spawn_entity_living packet) {
  size_t size = 0;
  size += size_varlong(packet.entity_id);
  size += 22;
  size += size_metadata(packet.metadata);
  return size;
}

char * dec_play_toclient_spawn_entity_living(play_toclient_spawn_entity_living *packet, char * source) {
  source = dec_varlong(&packet->entity_id, source);
  source = dec_byte(&packet->type, source);
  source = dec_be32(&packet->x, source);
  source = dec_be32(&packet->y, source);
  source = dec_be32(&packet->z, source);
  source = dec_byte(&packet->yaw, source);
  source = dec_byte(&packet->pitch, source);
  source = dec_byte(&packet->head_pitch, source);
  source = dec_be16(&packet->velocity_x, source);
  source = dec_be16(&packet->velocity_y, source);
  source = dec_be16(&packet->velocity_z, source);
  if(!(source = dec_metadata(&packet->metadata, source))) return NULL;
  return source;
}

char * enc_play_toclient_spawn_entity_living(char * dest, play_toclient_spawn_entity_living source) {
  dest = enc_varlong(dest, source.entity_id);
  dest = enc_byte(dest, source.type);
  dest = enc_be32(dest, source.x);
  dest = enc_be32(dest, source.y);
  dest = enc_be32(dest, source.z);
  dest = enc_byte(dest, source.yaw);
  dest = enc_byte(dest, source.pitch);
  dest = enc_byte(dest, source.head_pitch);
  dest = enc_be16(dest, source.velocity_x);
  dest = enc_be16(dest, source.velocity_y);
  dest = enc_be16(dest, source.velocity_z);
  dest = enc_metadata(dest, source.metadata);
  return dest;
}

void free_play_toclient_spawn_entity_living(play_toclient_spawn_entity_living packet) {
  free_metadata(packet.metadata);
}

int walk_play_toclient_spawn_entity_painting(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if((ret = walk_string(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if(max_len < 9) {
    return -1;
  }
  return size + 9;
}

size_t size_play_toclient_spawn_entity_painting(play_toclient_spawn_entity_painting packet) {
  size_t size = 0;
  size += size_varlong(packet.entity_id);
  size += size_string(packet.title);
  return size + 9;
}

char * dec_play_toclient_spawn_entity_painting(play_toclient_spawn_entity_painting *packet, char * source) {
  source = dec_varlong(&packet->entity_id, source);
  if(!(source = dec_string(&packet->title, source))) return NULL;
  source = dec_position(&packet->location, source);
  source = dec_byte(&packet->direction, source);
  return source;
}

char * enc_play_toclient_spawn_entity_painting(char * dest, play_toclient_spawn_entity_painting source) {
  dest = enc_varlong(dest, source.entity_id);
  dest = enc_string(dest, source.title);
  dest = enc_position(dest, source.location);
  dest = enc_byte(dest, source.direction);
  return dest;
}

void free_play_toclient_spawn_entity_painting(play_toclient_spawn_entity_painting packet) {
  free_string(packet.title);
}

int walk_play_toclient_spawn_entity_experience_orb(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if(max_len < 14) {
    return -1;
  }
  return size + 14;
}

size_t size_play_toclient_spawn_entity_experience_orb(play_toclient_spawn_entity_experience_orb packet) {
  size_t size = 0;
  size += size_varlong(packet.entity_id);
  return size + 14;
}

char * dec_play_toclient_spawn_entity_experience_orb(play_toclient_spawn_entity_experience_orb *packet, char * source) {
  source = dec_varlong(&packet->entity_id, source);
  source = dec_be32(&packet->x, source);
  source = dec_be32(&packet->y, source);
  source = dec_be32(&packet->z, source);
  source = dec_be16(&packet->count, source);
  return source;
}

char * enc_play_toclient_spawn_entity_experience_orb(char * dest, play_toclient_spawn_entity_experience_orb source) {
  dest = enc_varlong(dest, source.entity_id);
  dest = enc_be32(dest, source.x);
  dest = enc_be32(dest, source.y);
  dest = enc_be32(dest, source.z);
  dest = enc_be16(dest, source.count);
  return dest;
}

int walk_play_toclient_entity_velocity(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if(max_len < 6) {
    return -1;
  }
  return size + 6;
}

size_t size_play_toclient_entity_velocity(play_toclient_entity_velocity packet) {
  size_t size = 0;
  size += size_varlong(packet.entity_id);
  return size + 6;
}

char * dec_play_toclient_entity_velocity(play_toclient_entity_velocity *packet, char * source) {
  source = dec_varlong(&packet->entity_id, source);
  source = dec_be16(&packet->velocity_x, source);
  source = dec_be16(&packet->velocity_y, source);
  source = dec_be16(&packet->velocity_z, source);
  return source;
}

char * enc_play_toclient_entity_velocity(char * dest, play_toclient_entity_velocity source) {
  dest = enc_varlong(dest, source.entity_id);
  dest = enc_be16(dest, source.velocity_x);
  dest = enc_be16(dest, source.velocity_y);
  dest = enc_be16(dest, source.velocity_z);
  return dest;
}

int walk_play_toclient_entity_destroy(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_varlong(source, max_len)) < 0) {
      return -1;
  }
  size += ret;
  max_len -= ret;
  int64_t entity_ids_count;
  source = dec_varlong(&entity_ids_count, source);
  for(size_t i_0 = 0; i_0 < entity_ids_count; ++i_0) {
    if((ret = walk_varlong(source, max_len)) < 0) {
      return -1;
    }
    size += ret;
    source += ret;
    max_len -= ret;
  }
  return size;
}

size_t size_play_toclient_entity_destroy(play_toclient_entity_destroy packet) {
  size_t size = 0;
  size += size_varlong(packet.entity_ids.count);
  for(size_t i_0 = 0; i_0 < packet.entity_ids.count; ++i_0) {
    size += size_varlong(packet.entity_ids.base[i_0]);
  }
  return size;
}

char * dec_play_toclient_entity_destroy(play_toclient_entity_destroy *packet, char * source) {
  source = dec_varlong(&packet->entity_ids.count, source);
  if(!(packet->entity_ids.base = malloc(sizeof(*packet->entity_ids.base) * packet->entity_ids.count))) return NULL;
  for(size_t i_0 = 0; i_0 < packet->entity_ids.count; ++i_0) {
    source = dec_varlong(&packet->entity_ids.base[i_0], source);
  }
  return source;
}

char * enc_play_toclient_entity_destroy(char * dest, play_toclient_entity_destroy source) {
  dest = enc_varlong(dest, source.entity_ids.count);
  for(size_t i_0 = 0; i_0 < source.entity_ids.count; ++i_0) {
    dest = enc_varlong(dest, source.entity_ids.base[i_0]);
  }
  return dest;
}

void free_play_toclient_entity_destroy(play_toclient_entity_destroy packet) {
  free(packet.entity_ids.base);
}

int walk_play_toclient_entity(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  return size + ret;
}

size_t size_play_toclient_entity(play_toclient_entity packet) {
  size_t size = 0;
  size += size_varlong(packet.entity_id);
  return size;
}

char * dec_play_toclient_entity(play_toclient_entity *packet, char * source) {
  source = dec_varlong(&packet->entity_id, source);
  return source;
}

char * enc_play_toclient_entity(char * dest, play_toclient_entity source) {
  dest = enc_varlong(dest, source.entity_id);
  return dest;
}

int walk_play_toclient_rel_entity_move(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if(max_len < 4) {
    return -1;
  }
  return size + 4;
}

size_t size_play_toclient_rel_entity_move(play_toclient_rel_entity_move packet) {
  size_t size = 0;
  size += size_varlong(packet.entity_id);
  return size + 4;
}

char * dec_play_toclient_rel_entity_move(play_toclient_rel_entity_move *packet, char * source) {
  source = dec_varlong(&packet->entity_id, source);
  source = dec_byte(&packet->d_x, source);
  source = dec_byte(&packet->d_y, source);
  source = dec_byte(&packet->d_z, source);
  source = dec_byte(&packet->on_ground, source);
  return source;
}

char * enc_play_toclient_rel_entity_move(char * dest, play_toclient_rel_entity_move source) {
  dest = enc_varlong(dest, source.entity_id);
  dest = enc_byte(dest, source.d_x);
  dest = enc_byte(dest, source.d_y);
  dest = enc_byte(dest, source.d_z);
  dest = enc_byte(dest, source.on_ground);
  return dest;
}

int walk_play_toclient_entity_look(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if(max_len < 3) {
    return -1;
  }
  return size + 3;
}

size_t size_play_toclient_entity_look(play_toclient_entity_look packet) {
  size_t size = 0;
  size += size_varlong(packet.entity_id);
  return size + 3;
}

char * dec_play_toclient_entity_look(play_toclient_entity_look *packet, char * source) {
  source = dec_varlong(&packet->entity_id, source);
  source = dec_byte(&packet->yaw, source);
  source = dec_byte(&packet->pitch, source);
  source = dec_byte(&packet->on_ground, source);
  return source;
}

char * enc_play_toclient_entity_look(char * dest, play_toclient_entity_look source) {
  dest = enc_varlong(dest, source.entity_id);
  dest = enc_byte(dest, source.yaw);
  dest = enc_byte(dest, source.pitch);
  dest = enc_byte(dest, source.on_ground);
  return dest;
}

int walk_play_toclient_entity_move_look(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if(max_len < 6) {
    return -1;
  }
  return size + 6;
}

size_t size_play_toclient_entity_move_look(play_toclient_entity_move_look packet) {
  size_t size = 0;
  size += size_varlong(packet.entity_id);
  return size + 6;
}

char * dec_play_toclient_entity_move_look(play_toclient_entity_move_look *packet, char * source) {
  source = dec_varlong(&packet->entity_id, source);
  source = dec_byte(&packet->d_x, source);
  source = dec_byte(&packet->d_y, source);
  source = dec_byte(&packet->d_z, source);
  source = dec_byte(&packet->yaw, source);
  source = dec_byte(&packet->pitch, source);
  source = dec_byte(&packet->on_ground, source);
  return source;
}

char * enc_play_toclient_entity_move_look(char * dest, play_toclient_entity_move_look source) {
  dest = enc_varlong(dest, source.entity_id);
  dest = enc_byte(dest, source.d_x);
  dest = enc_byte(dest, source.d_y);
  dest = enc_byte(dest, source.d_z);
  dest = enc_byte(dest, source.yaw);
  dest = enc_byte(dest, source.pitch);
  dest = enc_byte(dest, source.on_ground);
  return dest;
}

int walk_play_toclient_entity_teleport(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if(max_len < 15) {
    return -1;
  }
  return size + 15;
}

size_t size_play_toclient_entity_teleport(play_toclient_entity_teleport packet) {
  size_t size = 0;
  size += size_varlong(packet.entity_id);
  return size + 15;
}

char * dec_play_toclient_entity_teleport(play_toclient_entity_teleport *packet, char * source) {
  source = dec_varlong(&packet->entity_id, source);
  source = dec_be32(&packet->x, source);
  source = dec_be32(&packet->y, source);
  source = dec_be32(&packet->z, source);
  source = dec_byte(&packet->yaw, source);
  source = dec_byte(&packet->pitch, source);
  source = dec_byte(&packet->on_ground, source);
  return source;
}

char * enc_play_toclient_entity_teleport(char * dest, play_toclient_entity_teleport source) {
  dest = enc_varlong(dest, source.entity_id);
  dest = enc_be32(dest, source.x);
  dest = enc_be32(dest, source.y);
  dest = enc_be32(dest, source.z);
  dest = enc_byte(dest, source.yaw);
  dest = enc_byte(dest, source.pitch);
  dest = enc_byte(dest, source.on_ground);
  return dest;
}

int walk_play_toclient_entity_head_rotation(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if(max_len < 1) {
    return -1;
  }
  return size + 1;
}

size_t size_play_toclient_entity_head_rotation(play_toclient_entity_head_rotation packet) {
  size_t size = 0;
  size += size_varlong(packet.entity_id);
  return size + 1;
}

char * dec_play_toclient_entity_head_rotation(play_toclient_entity_head_rotation *packet, char * source) {
  source = dec_varlong(&packet->entity_id, source);
  source = dec_byte(&packet->head_yaw, source);
  return source;
}

char * enc_play_toclient_entity_head_rotation(char * dest, play_toclient_entity_head_rotation source) {
  dest = enc_varlong(dest, source.entity_id);
  dest = enc_byte(dest, source.head_yaw);
  return dest;
}

int walk_play_toclient_entity_status(char * source, size_t max_len) {
  if(max_len < 5) return -1;
  return 5;
}

size_t size_play_toclient_entity_status(play_toclient_entity_status packet) {
  return 5;
}

char * dec_play_toclient_entity_status(play_toclient_entity_status *packet, char * source) {
  source = dec_be32(&packet->entity_id, source);
  source = dec_byte(&packet->entity_status, source);
  return source;
}

char * enc_play_toclient_entity_status(char * dest, play_toclient_entity_status source) {
  dest = enc_be32(dest, source.entity_id);
  dest = enc_byte(dest, source.entity_status);
  return dest;
}

int walk_play_toclient_attach_entity(char * source, size_t max_len) {
  if(max_len < 9) return -1;
  return 9;
}

size_t size_play_toclient_attach_entity(play_toclient_attach_entity packet) {
  return 9;
}

char * dec_play_toclient_attach_entity(play_toclient_attach_entity *packet, char * source) {
  source = dec_be32(&packet->entity_id, source);
  source = dec_be32(&packet->vehicle_id, source);
  source = dec_byte(&packet->leash, source);
  return source;
}

char * enc_play_toclient_attach_entity(char * dest, play_toclient_attach_entity source) {
  dest = enc_be32(dest, source.entity_id);
  dest = enc_be32(dest, source.vehicle_id);
  dest = enc_byte(dest, source.leash);
  return dest;
}

int walk_play_toclient_entity_metadata(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if((ret = walk_metadata(source, max_len)) < 0) {
    return -1;
  }
  return size + ret;
}

size_t size_play_toclient_entity_metadata(play_toclient_entity_metadata packet) {
  size_t size = 0;
  size += size_varlong(packet.entity_id);
  size += size_metadata(packet.metadata);
  return size;
}

char * dec_play_toclient_entity_metadata(play_toclient_entity_metadata *packet, char * source) {
  source = dec_varlong(&packet->entity_id, source);
  if(!(source = dec_metadata(&packet->metadata, source))) return NULL;
  return source;
}

char * enc_play_toclient_entity_metadata(char * dest, play_toclient_entity_metadata source) {
  dest = enc_varlong(dest, source.entity_id);
  dest = enc_metadata(dest, source.metadata);
  return dest;
}

void free_play_toclient_entity_metadata(play_toclient_entity_metadata packet) {
  free_metadata(packet.metadata);
}

int walk_play_toclient_entity_effect(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if(max_len < 2) {
    return -1;
  }
  size += 2;
  source += 2;
  max_len -= 2;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if(max_len < 1) {
    return -1;
  }
  return size + 1;
}

size_t size_play_toclient_entity_effect(play_toclient_entity_effect packet) {
  size_t size = 0;
  size += size_varlong(packet.entity_id);
  size += 2;
  size += size_varlong(packet.duration);
  return size + 1;
}

char * dec_play_toclient_entity_effect(play_toclient_entity_effect *packet, char * source) {
  source = dec_varlong(&packet->entity_id, source);
  source = dec_byte(&packet->effect_id, source);
  source = dec_byte(&packet->amplifier, source);
  source = dec_varlong(&packet->duration, source);
  source = dec_byte(&packet->hide_particles, source);
  return source;
}

char * enc_play_toclient_entity_effect(char * dest, play_toclient_entity_effect source) {
  dest = enc_varlong(dest, source.entity_id);
  dest = enc_byte(dest, source.effect_id);
  dest = enc_byte(dest, source.amplifier);
  dest = enc_varlong(dest, source.duration);
  dest = enc_byte(dest, source.hide_particles);
  return dest;
}

int walk_play_toclient_remove_entity_effect(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if(max_len < 1) {
    return -1;
  }
  return size + 1;
}

size_t size_play_toclient_remove_entity_effect(play_toclient_remove_entity_effect packet) {
  size_t size = 0;
  size += size_varlong(packet.entity_id);
  return size + 1;
}

char * dec_play_toclient_remove_entity_effect(play_toclient_remove_entity_effect *packet, char * source) {
  source = dec_varlong(&packet->entity_id, source);
  source = dec_byte(&packet->effect_id, source);
  return source;
}

char * enc_play_toclient_remove_entity_effect(char * dest, play_toclient_remove_entity_effect source) {
  dest = enc_varlong(dest, source.entity_id);
  dest = enc_byte(dest, source.effect_id);
  return dest;
}

int walk_play_toclient_experience(char * source, size_t max_len) {
  int ret, size = 0;
  if(max_len < 4) {
    return -1;
  }
  size += 4;
  source += 4;
  max_len -= 4;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  return size + ret;
}

size_t size_play_toclient_experience(play_toclient_experience packet) {
  size_t size = 0;
  size += 4;
  size += size_varlong(packet.level);
  size += size_varlong(packet.total_experience);
  return size;
}

char * dec_play_toclient_experience(play_toclient_experience *packet, char * source) {
  source = dec_bef32(&packet->experience_bar, source);
  source = dec_varlong(&packet->level, source);
  source = dec_varlong(&packet->total_experience, source);
  return source;
}

char * enc_play_toclient_experience(char * dest, play_toclient_experience source) {
  dest = enc_bef32(dest, source.experience_bar);
  dest = enc_varlong(dest, source.level);
  dest = enc_varlong(dest, source.total_experience);
  return dest;
}

int walk_play_toclient_update_attributes(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if(max_len < 4) {
    return -1;
  }
  size += 4;
  max_len -= 4;
  int32_t properties_count;
  source = dec_be32(&properties_count, source);
  for(size_t i_0 = 0; i_0 < properties_count; ++i_0) {
    if((ret = walk_string(source, max_len)) < 0) {
      return -1;
    }
    size += ret;
    source += ret;
    max_len -= ret;
    if(max_len < 8) {
      return -1;
    }
    size += 8;
    source += 8;
    max_len -= 8;
    if((ret = walk_varlong(source, max_len)) < 0) {
      return -1;
    }
    size += ret;
    max_len -= ret;
    int64_t modifiers_count;
    source = dec_varlong(&modifiers_count, source);
    if(max_len < modifiers_count * 25) {
      return -1;
    }
    size += modifiers_count * 25;
    source += modifiers_count * 25;
    max_len -= modifiers_count * 25;
  }
  return size;
}

size_t size_play_toclient_update_attributes(play_toclient_update_attributes packet) {
  size_t size = 0;
  size += size_varlong(packet.entity_id);
  size += 4;
  for(size_t i_0 = 0; i_0 < packet.properties.count; ++i_0) {
    size += size_string(packet.properties.base[i_0].key);
    size += 8;
    size += size_varlong(packet.properties.base[i_0].modifiers.count);
    size += packet.properties.base[i_0].modifiers.count * 25;
  }
  return size;
}

char * dec_play_toclient_update_attributes(play_toclient_update_attributes *packet, char * source) {
  source = dec_varlong(&packet->entity_id, source);
  source = dec_be32(&packet->properties.count, source);
  if(!(packet->properties.base = malloc(sizeof(*packet->properties.base) * packet->properties.count))) return NULL;
  for(size_t i_0 = 0; i_0 < packet->properties.count; ++i_0) {
    if(!(source = dec_string(&packet->properties.base[i_0].key, source))) return NULL;
    source = dec_bef64(&packet->properties.base[i_0].value, source);
    source = dec_varlong(&packet->properties.base[i_0].modifiers.count, source);
    if(!(packet->properties.base[i_0].modifiers.base = malloc(sizeof(*packet->properties.base[i_0].modifiers.base) * packet->properties.base[i_0].modifiers.count))) return NULL;
    for(size_t i_2 = 0; i_2 < packet->properties.base[i_0].modifiers.count; ++i_2) {
      source = dec_uuid(&packet->properties.base[i_0].modifiers.base[i_2].uuid, source);
      source = dec_bef64(&packet->properties.base[i_0].modifiers.base[i_2].amount, source);
      source = dec_byte(&packet->properties.base[i_0].modifiers.base[i_2].operation, source);
    }
  }
  return source;
}

char * enc_play_toclient_update_attributes(char * dest, play_toclient_update_attributes source) {
  dest = enc_varlong(dest, source.entity_id);
  dest = enc_be32(dest, source.properties.count);
  for(size_t i_0 = 0; i_0 < source.properties.count; ++i_0) {
    dest = enc_string(dest, source.properties.base[i_0].key);
    dest = enc_bef64(dest, source.properties.base[i_0].value);
    dest = enc_varlong(dest, source.properties.base[i_0].modifiers.count);
    for(size_t i_2 = 0; i_2 < source.properties.base[i_0].modifiers.count; ++i_2) {
      dest = enc_uuid(dest, source.properties.base[i_0].modifiers.base[i_2].uuid);
      dest = enc_bef64(dest, source.properties.base[i_0].modifiers.base[i_2].amount);
      dest = enc_byte(dest, source.properties.base[i_0].modifiers.base[i_2].operation);
    }
  }
  return dest;
}

void free_play_toclient_update_attributes(play_toclient_update_attributes packet) {
  for(size_t i_0 = 0; i_0 < packet.properties.count; ++i_0) {
    free_string(packet.properties.base[i_0].key);
    free(packet.properties.base[i_0].modifiers.base);
  }
  free(packet.properties.base);
}

int walk_play_toclient_map_chunk(char * source, size_t max_len) {
  int ret, size = 0;
  if(max_len < 11) {
    return -1;
  }
  size += 11;
  source += 11;
  max_len -= 11;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  max_len -= ret;
  int64_t chunk_data_len;
  source = dec_varlong(&chunk_data_len, source);
  if(max_len < chunk_data_len) {
    return -1;
  }
  size += chunk_data_len;
  source += chunk_data_len;
  max_len -= chunk_data_len;
  return size;
}

size_t size_play_toclient_map_chunk(play_toclient_map_chunk packet) {
  size_t size = 0;
  size += 11;
  size += size_varlong(packet.chunk_data.len);
  size += packet.chunk_data.len;
  return size;
}

char * dec_play_toclient_map_chunk(play_toclient_map_chunk *packet, char * source) {
  source = dec_be32(&packet->x, source);
  source = dec_be32(&packet->z, source);
  source = dec_byte(&packet->ground_up, source);
  source = dec_be16(&packet->bit_map, source);
  source = dec_varlong(&packet->chunk_data.len, source);
  if(!(packet->chunk_data.base = malloc(packet->chunk_data.len))) return NULL;
  memcpy(packet->chunk_data.base, source, packet->chunk_data.len);
  source += packet->chunk_data.len;
  return source;
}

char * enc_play_toclient_map_chunk(char * dest, play_toclient_map_chunk source) {
  dest = enc_be32(dest, source.x);
  dest = enc_be32(dest, source.z);
  dest = enc_byte(dest, source.ground_up);
  dest = enc_be16(dest, source.bit_map);
  dest = enc_varlong(dest, source.chunk_data.len);
  dest = memcpy(dest, source.chunk_data.base, source.chunk_data.len);
  return dest;
}

void free_play_toclient_map_chunk(play_toclient_map_chunk packet) {
  free(packet.chunk_data.base);
}

int walk_play_toclient_multi_block_change(char * source, size_t max_len) {
  int ret, size = 0;
  if(max_len < 8) {
      return -1;
  }
  size += 8;
  source += 8;
  max_len -= 8;
  if((ret = walk_varlong(source, max_len)) < 0) {
      return -1;
  }
  size += ret;
  max_len -= ret;
  int64_t records_count;
  source = dec_varlong(&records_count, source);
  for(size_t i_0 = 0; i_0 < records_count; ++i_0) {
    if(max_len < 2) {
      return -1;
    }
    size += 2;
    source += 2;
    max_len -= 2;
    if((ret = walk_varlong(source, max_len)) < 0) {
      return -1;
    }
    size += ret;
    source += ret;
    max_len -= ret;
  }
  return size;
}

size_t size_play_toclient_multi_block_change(play_toclient_multi_block_change packet) {
  size_t size = 0;
  size += 8;
  size += size_varlong(packet.records.count);
  for(size_t i_0 = 0; i_0 < packet.records.count; ++i_0) {
    size += 2;
    size += size_varlong(packet.records.base[i_0].block_id);
  }
  return size;
}

char * dec_play_toclient_multi_block_change(play_toclient_multi_block_change *packet, char * source) {
  source = dec_be32(&packet->chunk_x, source);
  source = dec_be32(&packet->chunk_z, source);
  source = dec_varlong(&packet->records.count, source);
  if(!(packet->records.base = malloc(sizeof(*packet->records.base) * packet->records.count))) return NULL;
  for(size_t i_0 = 0; i_0 < packet->records.count; ++i_0) {
    source = dec_byte(&packet->records.base[i_0].horizontal_pos, source);
    source = dec_byte(&packet->records.base[i_0].y, source);
    source = dec_varlong(&packet->records.base[i_0].block_id, source);
  }
  return source;
}

char * enc_play_toclient_multi_block_change(char * dest, play_toclient_multi_block_change source) {
  dest = enc_be32(dest, source.chunk_x);
  dest = enc_be32(dest, source.chunk_z);
  dest = enc_varlong(dest, source.records.count);
  for(size_t i_0 = 0; i_0 < source.records.count; ++i_0) {
    dest = enc_byte(dest, source.records.base[i_0].horizontal_pos);
    dest = enc_byte(dest, source.records.base[i_0].y);
    dest = enc_varlong(dest, source.records.base[i_0].block_id);
  }
  return dest;
}

void free_play_toclient_multi_block_change(play_toclient_multi_block_change packet) {
  free(packet.records.base);
}

int walk_play_toclient_block_change(char * source, size_t max_len) {
  int ret, size = 0;
  if(max_len < 8) {
    return -1;
  }
  size += 8;
  source += 8;
  max_len -= 8;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  return size + ret;
}

size_t size_play_toclient_block_change(play_toclient_block_change packet) {
  size_t size = 0;
  size += 8;
  size += size_varlong(packet.type);
  return size;
}

char * dec_play_toclient_block_change(play_toclient_block_change *packet, char * source) {
  source = dec_position(&packet->location, source);
  source = dec_varlong(&packet->type, source);
  return source;
}

char * enc_play_toclient_block_change(char * dest, play_toclient_block_change source) {
  dest = enc_position(dest, source.location);
  dest = enc_varlong(dest, source.type);
  return dest;
}

int walk_play_toclient_block_action(char * source, size_t max_len) {
  int ret, size = 0;
  if(max_len < 10) {
    return -1;
  }
  size += 10;
  source += 10;
  max_len -= 10;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  return size + ret;
}

size_t size_play_toclient_block_action(play_toclient_block_action packet) {
  size_t size = 0;
  size += 10;
  size += size_varlong(packet.block_id);
  return size;
}

char * dec_play_toclient_block_action(play_toclient_block_action *packet, char * source) {
  source = dec_position(&packet->location, source);
  source = dec_byte(&packet->byte1, source);
  source = dec_byte(&packet->byte2, source);
  source = dec_varlong(&packet->block_id, source);
  return source;
}

char * enc_play_toclient_block_action(char * dest, play_toclient_block_action source) {
  dest = enc_position(dest, source.location);
  dest = enc_byte(dest, source.byte1);
  dest = enc_byte(dest, source.byte2);
  dest = enc_varlong(dest, source.block_id);
  return dest;
}

int walk_play_toclient_block_break_animation(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if(max_len < 9) {
    return -1;
  }
  return size + 9;
}

size_t size_play_toclient_block_break_animation(play_toclient_block_break_animation packet) {
  size_t size = 0;
  size += size_varlong(packet.entity_id);
  return size + 9;
}

char * dec_play_toclient_block_break_animation(play_toclient_block_break_animation *packet, char * source) {
  source = dec_varlong(&packet->entity_id, source);
  source = dec_position(&packet->location, source);
  source = dec_byte(&packet->destroy_stage, source);
  return source;
}

char * enc_play_toclient_block_break_animation(char * dest, play_toclient_block_break_animation source) {
  dest = enc_varlong(dest, source.entity_id);
  dest = enc_position(dest, source.location);
  dest = enc_byte(dest, source.destroy_stage);
  return dest;
}

int walk_play_toclient_map_chunk_bulk(char * source, size_t max_len) {
  int ret, size = 0;
  if(max_len < 1) {
    return -1;
  }
  size += 1;
  source += 1;
  max_len -= 1;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  max_len -= ret;
  int64_t meta_count;
  source = dec_varlong(&meta_count, source);
  if(max_len < meta_count * 10) {
    return -1;
  }
  size += meta_count * 10;
  source += meta_count * 10;
  max_len -= meta_count * 10;
  ret = max_len;
  return size + ret;
}

size_t size_play_toclient_map_chunk_bulk(play_toclient_map_chunk_bulk packet) {
  size_t size = 0;
  size += 1;
  size += size_varlong(packet.meta.count);
  size += packet.meta.count * 10;
  size += packet.data.len;
  return size;
}

char * dec_play_toclient_map_chunk_bulk(play_toclient_map_chunk_bulk *packet, char * source, size_t total_size) {
  char * endptr = source + total_size;
  source = dec_byte(&packet->sky_light_sent, source);
  source = dec_varlong(&packet->meta.count, source);
  if(!(packet->meta.base = malloc(sizeof(*packet->meta.base) * packet->meta.count))) return NULL;
  for(size_t i_0 = 0; i_0 < packet->meta.count; ++i_0) {
    source = dec_be32(&packet->meta.base[i_0].x, source);
    source = dec_be32(&packet->meta.base[i_0].z, source);
    source = dec_be16(&packet->meta.base[i_0].bit_map, source);
  }
  source = dec_buffer(&packet->data, source, endptr - source);
  return source;
}

char * enc_play_toclient_map_chunk_bulk(char * dest, play_toclient_map_chunk_bulk source) {
  dest = enc_byte(dest, source.sky_light_sent);
  dest = enc_varlong(dest, source.meta.count);
  for(size_t i_0 = 0; i_0 < source.meta.count; ++i_0) {
    dest = enc_be32(dest, source.meta.base[i_0].x);
    dest = enc_be32(dest, source.meta.base[i_0].z);
    dest = enc_be16(dest, source.meta.base[i_0].bit_map);
  }
  dest = enc_buffer(dest, source.data);
  return dest;
}

void free_play_toclient_map_chunk_bulk(play_toclient_map_chunk_bulk packet) {
  free(packet.meta.base);
  free(packet.data.base);
}

int walk_play_toclient_explosion(char * source, size_t max_len) {
  int ret, size = 0;
  if(max_len < 16) {
    return -1;
  }
  size += 16;
  source += 16;
  max_len -= 16;
  if(max_len < 4) {
    return -1;
  }
  size += 4;
  max_len -= 4;
  int32_t affected_block_offsets_count;
  source = dec_be32(&affected_block_offsets_count, source);
  if(max_len < affected_block_offsets_count * 3) {
    return -1;
  }
  size += affected_block_offsets_count * 3;
  source += affected_block_offsets_count * 3;
  max_len -= affected_block_offsets_count * 3;
  if(max_len < 12) {
    return -1;
  }
  return size + 12;
}

size_t size_play_toclient_explosion(play_toclient_explosion packet) {
  size_t size = 0;
  size += 16;
  size += 4;
  size += packet.affected_block_offsets.count * 3;
  return size + 12;
}

char * dec_play_toclient_explosion(play_toclient_explosion *packet, char * source) {
  source = dec_bef32(&packet->x, source);
  source = dec_bef32(&packet->y, source);
  source = dec_bef32(&packet->z, source);
  source = dec_bef32(&packet->radius, source);
  source = dec_be32(&packet->affected_block_offsets.count, source);
  if(!(packet->affected_block_offsets.base = malloc(sizeof(*packet->affected_block_offsets.base) * packet->affected_block_offsets.count))) return NULL;
  for(size_t i_0 = 0; i_0 < packet->affected_block_offsets.count; ++i_0) {
    source = dec_byte(&packet->affected_block_offsets.base[i_0].x, source);
    source = dec_byte(&packet->affected_block_offsets.base[i_0].y, source);
    source = dec_byte(&packet->affected_block_offsets.base[i_0].z, source);
  }
  source = dec_bef32(&packet->player_motion_x, source);
  source = dec_bef32(&packet->player_motion_y, source);
  source = dec_bef32(&packet->player_motion_z, source);
  return source;
}

char * enc_play_toclient_explosion(char * dest, play_toclient_explosion source) {
  dest = enc_bef32(dest, source.x);
  dest = enc_bef32(dest, source.y);
  dest = enc_bef32(dest, source.z);
  dest = enc_bef32(dest, source.radius);
  dest = enc_be32(dest, source.affected_block_offsets.count);
  for(size_t i_0 = 0; i_0 < source.affected_block_offsets.count; ++i_0) {
    dest = enc_byte(dest, source.affected_block_offsets.base[i_0].x);
    dest = enc_byte(dest, source.affected_block_offsets.base[i_0].y);
    dest = enc_byte(dest, source.affected_block_offsets.base[i_0].z);
  }
  dest = enc_bef32(dest, source.player_motion_x);
  dest = enc_bef32(dest, source.player_motion_y);
  dest = enc_bef32(dest, source.player_motion_z);
  return dest;
}

void free_play_toclient_explosion(play_toclient_explosion packet) {
  free(packet.affected_block_offsets.base);
}

int walk_play_toclient_world_event(char * source, size_t max_len) {
  if(max_len < 17) return -1;
  return 17;
}

size_t size_play_toclient_world_event(play_toclient_world_event packet) {
  return 17;
}

char * dec_play_toclient_world_event(play_toclient_world_event *packet, char * source) {
  source = dec_be32(&packet->effect_id, source);
  source = dec_position(&packet->location, source);
  source = dec_be32(&packet->data, source);
  source = dec_byte(&packet->global, source);
  return source;
}

char * enc_play_toclient_world_event(char * dest, play_toclient_world_event source) {
  dest = enc_be32(dest, source.effect_id);
  dest = enc_position(dest, source.location);
  dest = enc_be32(dest, source.data);
  dest = enc_byte(dest, source.global);
  return dest;
}

int walk_play_toclient_named_sound_effect(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_string(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if(max_len < 17) {
    return -1;
  }
  return size + 17;
}

size_t size_play_toclient_named_sound_effect(play_toclient_named_sound_effect packet) {
  size_t size = 0;
  size += size_string(packet.sound_name);
  return size + 17;
}

char * dec_play_toclient_named_sound_effect(play_toclient_named_sound_effect *packet, char * source) {
  if(!(source = dec_string(&packet->sound_name, source))) return NULL;
  source = dec_be32(&packet->x, source);
  source = dec_be32(&packet->y, source);
  source = dec_be32(&packet->z, source);
  source = dec_bef32(&packet->volume, source);
  source = dec_byte(&packet->pitch, source);
  return source;
}

char * enc_play_toclient_named_sound_effect(char * dest, play_toclient_named_sound_effect source) {
  dest = enc_string(dest, source.sound_name);
  dest = enc_be32(dest, source.x);
  dest = enc_be32(dest, source.y);
  dest = enc_be32(dest, source.z);
  dest = enc_bef32(dest, source.volume);
  dest = enc_byte(dest, source.pitch);
  return dest;
}

void free_play_toclient_named_sound_effect(play_toclient_named_sound_effect packet) {
  free_string(packet.sound_name);
}

int walk_play_toclient_world_particles(char * source, size_t max_len) {
  int ret, size = 0;
  int32_t particle_id;
  if(max_len < 4) {
    return -1;
  }
  size += 4;
  max_len -= 4;
  source = dec_be32(&particle_id, source);
  if(max_len < 33) {
    return -1;
  }
  size += 33;
  source += 33;
  max_len -= 33;
  switch(particle_id) {
    case 36:
      for(size_t i_1 = 0; i_1 < 2; ++i_1) {
        if((ret = walk_varlong(source, max_len)) < 0) {
          return -1;
        }
        size += ret;
        source += ret;
        max_len -= ret;
      }
      break;
    case 38:
    case 37:
      for(size_t i_1 = 0; i_1 < 1; ++i_1) {
        if((ret = walk_varlong(source, max_len)) < 0) {
          return -1;
        }
        size += ret;
        source += ret;
        max_len -= ret;
      }
      break;
  }
  return size;
}

size_t size_play_toclient_world_particles(play_toclient_world_particles packet) {
  size_t size = 0;
  size += 37;
  switch(packet.particle_id) {
    case 36:
      for(size_t i_1 = 0; i_1 < 2; ++i_1) {
        size += size_varlong(packet.data.enum_36.base[i_1]);
      }
      break;
    case 38:
    case 37:
      for(size_t i_1 = 0; i_1 < 1; ++i_1) {
        size += size_varlong(packet.data.enum_37.base[i_1]);
      }
      break;
  }
  return size;
}

char * dec_play_toclient_world_particles(play_toclient_world_particles *packet, char * source) {
  source = dec_be32(&packet->particle_id, source);
  source = dec_byte(&packet->long_distance, source);
  source = dec_bef32(&packet->x, source);
  source = dec_bef32(&packet->y, source);
  source = dec_bef32(&packet->z, source);
  source = dec_bef32(&packet->offset_x, source);
  source = dec_bef32(&packet->offset_y, source);
  source = dec_bef32(&packet->offset_z, source);
  source = dec_bef32(&packet->particle_data, source);
  source = dec_be32(&packet->particles, source);
  switch(packet->particle_id) {
    case 36:
      if(!(packet->data.enum_36.base = malloc(sizeof(*packet->data.enum_36.base) * 2))) return NULL;
      for(size_t i_1 = 0; i_1 < 2; ++i_1) {
        source = dec_varlong(&packet->data.enum_36.base[i_1], source);
      }
      break;
    case 38:
    case 37:
      if(!(packet->data.enum_37.base = malloc(sizeof(*packet->data.enum_37.base) * 1))) return NULL;
      for(size_t i_1 = 0; i_1 < 1; ++i_1) {
        source = dec_varlong(&packet->data.enum_37.base[i_1], source);
      }
      break;
  }
  return source;
}

char * enc_play_toclient_world_particles(char * dest, play_toclient_world_particles source) {
  dest = enc_be32(dest, source.particle_id);
  dest = enc_byte(dest, source.long_distance);
  dest = enc_bef32(dest, source.x);
  dest = enc_bef32(dest, source.y);
  dest = enc_bef32(dest, source.z);
  dest = enc_bef32(dest, source.offset_x);
  dest = enc_bef32(dest, source.offset_y);
  dest = enc_bef32(dest, source.offset_z);
  dest = enc_bef32(dest, source.particle_data);
  dest = enc_be32(dest, source.particles);
  switch(source.particle_id) {
    case 36:
      for(size_t i_1 = 0; i_1 < 2; ++i_1) {
        dest = enc_varlong(dest, source.data.enum_36.base[i_1]);
      }
      break;
    case 38:
    case 37:
      for(size_t i_1 = 0; i_1 < 1; ++i_1) {
        dest = enc_varlong(dest, source.data.enum_37.base[i_1]);
      }
      break;
  }
  return dest;
}

void free_play_toclient_world_particles(play_toclient_world_particles packet) {
  switch(packet.particle_id) {
    case 36:
      free(packet.data.enum_36.base);
      break;
    case 38:
    case 37:
      free(packet.data.enum_37.base);
      break;
  }
}

int walk_play_toclient_game_state_change(char * source, size_t max_len) {
  if(max_len < 5) return -1;
  return 5;
}

size_t size_play_toclient_game_state_change(play_toclient_game_state_change packet) {
  return 5;
}

char * dec_play_toclient_game_state_change(play_toclient_game_state_change *packet, char * source) {
  source = dec_byte(&packet->reason, source);
  source = dec_bef32(&packet->game_mode, source);
  return source;
}

char * enc_play_toclient_game_state_change(char * dest, play_toclient_game_state_change source) {
  dest = enc_byte(dest, source.reason);
  dest = enc_bef32(dest, source.game_mode);
  return dest;
}

int walk_play_toclient_spawn_entity_weather(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if(max_len < 13) {
    return -1;
  }
  return size + 13;
}

size_t size_play_toclient_spawn_entity_weather(play_toclient_spawn_entity_weather packet) {
  size_t size = 0;
  size += size_varlong(packet.entity_id);
  return size + 13;
}

char * dec_play_toclient_spawn_entity_weather(play_toclient_spawn_entity_weather *packet, char * source) {
  source = dec_varlong(&packet->entity_id, source);
  source = dec_byte(&packet->type, source);
  source = dec_be32(&packet->x, source);
  source = dec_be32(&packet->y, source);
  source = dec_be32(&packet->z, source);
  return source;
}

char * enc_play_toclient_spawn_entity_weather(char * dest, play_toclient_spawn_entity_weather source) {
  dest = enc_varlong(dest, source.entity_id);
  dest = enc_byte(dest, source.type);
  dest = enc_be32(dest, source.x);
  dest = enc_be32(dest, source.y);
  dest = enc_be32(dest, source.z);
  return dest;
}

int walk_play_toclient_open_window(char * source, size_t max_len) {
  int ret, size = 0;
  if(max_len < 1) {
    return -1;
  }
  size += 1;
  source += 1;
  max_len -= 1;
  sds inventory_type;
  if((ret = walk_string(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  max_len -= ret;
  if(!(source = dec_string(&inventory_type, source))) {
    return -1;
  }
  if((ret = walk_string(source, max_len)) < 0) {
    free_string(inventory_type);
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if(max_len < 1) {
      free_string(inventory_type);
      return -1;
  }
  size += 1;
  source += 1;
  max_len -= 1;
  if(!(sdscmp("EntityHorse", inventory_type))) {
    if(max_len < 4) {
      free_string(inventory_type);
      return -1;
    }
    size += 4;
    source += 4;
    max_len -= 4;
  }
  return size;
  free_string(inventory_type);
}

size_t size_play_toclient_open_window(play_toclient_open_window packet) {
  size_t size = 0;
  size += 1;
  size += size_string(packet.inventory_type);
  size += size_string(packet.window_title);
  size += 1;
  if(!(sdscmp("EntityHorse", packet.inventory_type))) {
    size += 4;
  }
  return size;
}

char * dec_play_toclient_open_window(play_toclient_open_window *packet, char * source) {
  source = dec_byte(&packet->window_id, source);
  if(!(source = dec_string(&packet->inventory_type, source))) return NULL;
  if(!(source = dec_string(&packet->window_title, source))) return NULL;
  source = dec_byte(&packet->slot_count, source);
  if(!(sdscmp("EntityHorse", packet->inventory_type))) {
    source = dec_be32(&packet->entity_id, source);
  }
  return source;
}

char * enc_play_toclient_open_window(char * dest, play_toclient_open_window source) {
  dest = enc_byte(dest, source.window_id);
  dest = enc_string(dest, source.inventory_type);
  dest = enc_string(dest, source.window_title);
  dest = enc_byte(dest, source.slot_count);
  if(!(sdscmp("EntityHorse", source.inventory_type))) {
    dest = enc_be32(dest, source.entity_id);
  }
  return dest;
}

void free_play_toclient_open_window(play_toclient_open_window packet) {
  free_string(packet.inventory_type);
  free_string(packet.window_title);
}

int walk_play_toclient_close_window(char * source, size_t max_len) {
  if(max_len < 1) return -1;
  return 1;
}

size_t size_play_toclient_close_window(play_toclient_close_window packet) {
  return 1;
}

char * dec_play_toclient_close_window(play_toclient_close_window *packet, char * source) {
  source = dec_byte(&packet->window_id, source);
  return source;
}

char * enc_play_toclient_close_window(char * dest, play_toclient_close_window source) {
  dest = enc_byte(dest, source.window_id);
  return dest;
}

int walk_play_toclient_set_slot(char * source, size_t max_len) {
  int ret, size = 0;
  if(max_len < 3) {
    return -1;
  }
  size += 3;
  source += 3;
  max_len -= 3;
  if((ret = walk_slot(source, max_len)) < 0) {
    return -1;
  }
  return size + ret;
}

size_t size_play_toclient_set_slot(play_toclient_set_slot packet) {
  size_t size = 0;
  size += 3;
  size += size_slot(packet.item);
  return size;
}

char * dec_play_toclient_set_slot(play_toclient_set_slot *packet, char * source) {
  source = dec_byte(&packet->window_id, source);
  source = dec_be16(&packet->slot, source);
  if(!(source = dec_slot(&packet->item, source))) return NULL;
  return source;
}

char * enc_play_toclient_set_slot(char * dest, play_toclient_set_slot source) {
  dest = enc_byte(dest, source.window_id);
  dest = enc_be16(dest, source.slot);
  dest = enc_slot(dest, source.item);
  return dest;
}

void free_play_toclient_set_slot(play_toclient_set_slot packet) {
  free_slot(packet.item);
}

int walk_play_toclient_window_items(char * source, size_t max_len) {
  int ret, size = 0;
  if(max_len < 1) {
      return -1;
  }
  size += 1;
  source += 1;
  max_len -= 1;
  if(max_len < 2) {
      return -1;
  }
  size += 2;
  max_len -= 2;
  int16_t items_count;
  source = dec_be16(&items_count, source);
  for(size_t i_0 = 0; i_0 < items_count; ++i_0) {
    if((ret = walk_slot(source, max_len)) < 0) {
      return -1;
    }
    size += ret;
    source += ret;
    max_len -= ret;
  }
  return size;
}

size_t size_play_toclient_window_items(play_toclient_window_items packet) {
  size_t size = 0;
  size += 1;
  size += 2;
  for(size_t i_0 = 0; i_0 < packet.items.count; ++i_0) {
    size += size_slot(packet.items.base[i_0]);
  }
  return size;
}

char * dec_play_toclient_window_items(play_toclient_window_items *packet, char * source) {
  source = dec_byte(&packet->window_id, source);
  source = dec_be16(&packet->items.count, source);
  if(!(packet->items.base = malloc(sizeof(*packet->items.base) * packet->items.count))) return NULL;
  for(size_t i_0 = 0; i_0 < packet->items.count; ++i_0) {
    if(!(source = dec_slot(&packet->items.base[i_0], source))) return NULL;
  }
  return source;
}

char * enc_play_toclient_window_items(char * dest, play_toclient_window_items source) {
  dest = enc_byte(dest, source.window_id);
  dest = enc_be16(dest, source.items.count);
  for(size_t i_0 = 0; i_0 < source.items.count; ++i_0) {
    dest = enc_slot(dest, source.items.base[i_0]);
  }
  return dest;
}

void free_play_toclient_window_items(play_toclient_window_items packet) {
  for(size_t i_0 = 0; i_0 < packet.items.count; ++i_0) {
    free_slot(packet.items.base[i_0]);
  }
  free(packet.items.base);
}

int walk_play_toclient_craft_progress_bar(char * source, size_t max_len) {
  if(max_len < 5) return -1;
  return 5;
}

size_t size_play_toclient_craft_progress_bar(play_toclient_craft_progress_bar packet) {
  return 5;
}

char * dec_play_toclient_craft_progress_bar(play_toclient_craft_progress_bar *packet, char * source) {
  source = dec_byte(&packet->window_id, source);
  source = dec_be16(&packet->property, source);
  source = dec_be16(&packet->value, source);
  return source;
}

char * enc_play_toclient_craft_progress_bar(char * dest, play_toclient_craft_progress_bar source) {
  dest = enc_byte(dest, source.window_id);
  dest = enc_be16(dest, source.property);
  dest = enc_be16(dest, source.value);
  return dest;
}

int walk_play_toclient_transaction(char * source, size_t max_len) {
  if(max_len < 4) return -1;
  return 4;
}

size_t size_play_toclient_transaction(play_toclient_transaction packet) {
  return 4;
}

char * dec_play_toclient_transaction(play_toclient_transaction *packet, char * source) {
  source = dec_byte(&packet->window_id, source);
  source = dec_be16(&packet->action, source);
  source = dec_byte(&packet->accepted, source);
  return source;
}

char * enc_play_toclient_transaction(char * dest, play_toclient_transaction source) {
  dest = enc_byte(dest, source.window_id);
  dest = enc_be16(dest, source.action);
  dest = enc_byte(dest, source.accepted);
  return dest;
}

int walk_play_toclient_update_sign(char * source, size_t max_len) {
  int ret, size = 0;
  if(max_len < 8) {
    return -1;
  }
  size += 8;
  source += 8;
  max_len -= 8;
  if((ret = walk_string(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if((ret = walk_string(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if((ret = walk_string(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if((ret = walk_string(source, max_len)) < 0) {
    return -1;
  }
  return size + ret;
}

size_t size_play_toclient_update_sign(play_toclient_update_sign packet) {
  size_t size = 0;
  size += 8;
  size += size_string(packet.text1);
  size += size_string(packet.text2);
  size += size_string(packet.text3);
  size += size_string(packet.text4);
  return size;
}

char * dec_play_toclient_update_sign(play_toclient_update_sign *packet, char * source) {
  source = dec_position(&packet->location, source);
  if(!(source = dec_string(&packet->text1, source))) return NULL;
  if(!(source = dec_string(&packet->text2, source))) return NULL;
  if(!(source = dec_string(&packet->text3, source))) return NULL;
  if(!(source = dec_string(&packet->text4, source))) return NULL;
  return source;
}

char * enc_play_toclient_update_sign(char * dest, play_toclient_update_sign source) {
  dest = enc_position(dest, source.location);
  dest = enc_string(dest, source.text1);
  dest = enc_string(dest, source.text2);
  dest = enc_string(dest, source.text3);
  dest = enc_string(dest, source.text4);
  return dest;
}

void free_play_toclient_update_sign(play_toclient_update_sign packet) {
  free_string(packet.text1);
  free_string(packet.text2);
  free_string(packet.text3);
  free_string(packet.text4);
}

int walk_play_toclient_map(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if(max_len < 1) {
    return -1;
  }
  size += 1;
  source += 1;
  max_len -= 1;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  max_len -= ret;
  int64_t icons_count;
  source = dec_varlong(&icons_count, source);
  if(max_len < icons_count * 3) {
    return -1;
  }
  size += icons_count * 3;
  source += icons_count * 3;
  max_len -= icons_count * 3;
  int8_t columns;
  if(max_len < 1) {
    return -1;
  }
  size += 1;
  max_len -= 1;
  source = dec_byte(&columns, source);
  switch(columns) {
    case 0:
      // void condition
      break;
    default:
      if(max_len < 1) {
        return -1;
      }
      size += 1;
      source += 1;
      max_len -= 1;
  }
  switch(columns) {
    case 0:
      // void condition
      break;
    default:
      if(max_len < 1) {
        return -1;
      }
      size += 1;
      source += 1;
      max_len -= 1;
  }
  switch(columns) {
    case 0:
      // void condition
      break;
    default:
      if(max_len < 1) {
        return -1;
      }
      size += 1;
      source += 1;
      max_len -= 1;
  }
  switch(columns) {
    case 0:
      // void condition
      break;
    default:
      if((ret = walk_varlong(source, max_len)) < 0) {
        return -1;
      }
      size += ret;
      max_len -= ret;
      int64_t data_len;
      source = dec_varlong(&data_len, source);
      if(max_len < data_len) {
        return -1;
      }
      size += data_len;
      source += data_len;
      max_len -= data_len;
  }
  return size;
}

size_t size_play_toclient_map(play_toclient_map packet) {
  size_t size = 0;
  size += size_varlong(packet.item_damage);
  size += 1;
  size += size_varlong(packet.icons.count);
  size += packet.icons.count * 3;
  size += 1;
  switch(packet.columns) {
    case 0:
      // void condition
      break;
    default:
      size += 1;
  }
  switch(packet.columns) {
    case 0:
      // void condition
      break;
    default:
      size += 1;
  }
  switch(packet.columns) {
    case 0:
      // void condition
      break;
    default:
      size += 1;
  }
  switch(packet.columns) {
    case 0:
      // void condition
      break;
    default:
      size += size_varlong(packet.data.len);
      size += packet.data.len;
  }
  return size;
}

char * dec_play_toclient_map(play_toclient_map *packet, char * source) {
  source = dec_varlong(&packet->item_damage, source);
  source = dec_byte(&packet->scale, source);
  source = dec_varlong(&packet->icons.count, source);
  if(!(packet->icons.base = malloc(sizeof(*packet->icons.base) * packet->icons.count))) return NULL;
  for(size_t i_0 = 0; i_0 < packet->icons.count; ++i_0) {
    source = dec_byte(&packet->icons.base[i_0].direction_and_type, source);
    source = dec_byte(&packet->icons.base[i_0].x, source);
    source = dec_byte(&packet->icons.base[i_0].z, source);
  }
  source = dec_byte(&packet->columns, source);
  switch(packet->columns) {
    case 0:
      // void condition
      break;
    default:
      source = dec_byte(&packet->rows, source);
  }
  switch(packet->columns) {
    case 0:
      // void condition
      break;
    default:
      source = dec_byte(&packet->x, source);
  }
  switch(packet->columns) {
    case 0:
      // void condition
      break;
    default:
      source = dec_byte(&packet->y, source);
  }
  switch(packet->columns) {
    case 0:
      // void condition
      break;
    default:
      source = dec_varlong(&packet->data.len, source);
      if(!(packet->data.base = malloc(packet->data.len))) return NULL;
      memcpy(packet->data.base, source, packet->data.len);
      source += packet->data.len;
  }
  return source;
}

char * enc_play_toclient_map(char * dest, play_toclient_map source) {
  dest = enc_varlong(dest, source.item_damage);
  dest = enc_byte(dest, source.scale);
  dest = enc_varlong(dest, source.icons.count);
  for(size_t i_0 = 0; i_0 < source.icons.count; ++i_0) {
    dest = enc_byte(dest, source.icons.base[i_0].direction_and_type);
    dest = enc_byte(dest, source.icons.base[i_0].x);
    dest = enc_byte(dest, source.icons.base[i_0].z);
  }
  dest = enc_byte(dest, source.columns);
  switch(source.columns) {
    case 0:
      // void condition
      break;
    default:
      dest = enc_byte(dest, source.rows);
  }
  switch(source.columns) {
    case 0:
      // void condition
      break;
    default:
      dest = enc_byte(dest, source.x);
  }
  switch(source.columns) {
    case 0:
      // void condition
      break;
    default:
      dest = enc_byte(dest, source.y);
  }
  switch(source.columns) {
    case 0:
      // void condition
      break;
    default:
      dest = enc_varlong(dest, source.data.len);
      dest = memcpy(dest, source.data.base, source.data.len);
  }
  return dest;
}

void free_play_toclient_map(play_toclient_map packet) {
  free(packet.icons.base);
  switch(packet.columns) {
    case 0:
      // No free-able types
      break;
    default:
      free(packet.data.base);
  }
}

int walk_play_toclient_tile_entity_data(char * source, size_t max_len) {
  int ret, size = 0;
  if(max_len < 9) {
    return -1;
  }
  size += 9;
  source += 9;
  max_len -= 9;
  if((ret = walk_optnbt(source, max_len)) < 0) {
    return -1;
  }
  return size + ret;
}

size_t size_play_toclient_tile_entity_data(play_toclient_tile_entity_data packet) {
  size_t size = 0;
  size += 9;
  size += size_optnbt(packet.nbt_data);
  return size;
}

char * dec_play_toclient_tile_entity_data(play_toclient_tile_entity_data *packet, char * source) {
  source = dec_position(&packet->location, source);
  source = dec_byte(&packet->action, source);
  if(!(source = dec_optnbt(&packet->nbt_data, source))) return NULL;
  return source;
}

char * enc_play_toclient_tile_entity_data(char * dest, play_toclient_tile_entity_data source) {
  dest = enc_position(dest, source.location);
  dest = enc_byte(dest, source.action);
  dest = enc_optnbt(dest, source.nbt_data);
  return dest;
}

void free_play_toclient_tile_entity_data(play_toclient_tile_entity_data packet) {
  free_optnbt(packet.nbt_data);
}

int walk_play_toclient_open_sign_entity(char * source, size_t max_len) {
  if(max_len < 8) return -1;
  return 8;
}

size_t size_play_toclient_open_sign_entity(play_toclient_open_sign_entity packet) {
  return 8;
}

char * dec_play_toclient_open_sign_entity(play_toclient_open_sign_entity *packet, char * source) {
  source = dec_position(&packet->location, source);
  return source;
}

char * enc_play_toclient_open_sign_entity(char * dest, play_toclient_open_sign_entity source) {
  dest = enc_position(dest, source.location);
  return dest;
}

int walk_play_toclient_statistics(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  max_len -= ret;
  int64_t entries_count;
  source = dec_varlong(&entries_count, source);
  for(size_t i_0 = 0; i_0 < entries_count; ++i_0) {
    if((ret = walk_string(source, max_len)) < 0) {
      return -1;
    }
    size += ret;
    source += ret;
    max_len -= ret;
    if((ret = walk_varlong(source, max_len)) < 0) {
      return -1;
    }
    size += ret;
    source += ret;
    max_len -= ret;
  }
  return size;
}

size_t size_play_toclient_statistics(play_toclient_statistics packet) {
  size_t size = 0;
  size += size_varlong(packet.entries.count);
  for(size_t i_0 = 0; i_0 < packet.entries.count; ++i_0) {
    size += size_string(packet.entries.base[i_0].name);
    size += size_varlong(packet.entries.base[i_0].value);
  }
  return size;
}

char * dec_play_toclient_statistics(play_toclient_statistics *packet, char * source) {
  source = dec_varlong(&packet->entries.count, source);
  if(!(packet->entries.base = malloc(sizeof(*packet->entries.base) * packet->entries.count))) return NULL;
  for(size_t i_0 = 0; i_0 < packet->entries.count; ++i_0) {
    if(!(source = dec_string(&packet->entries.base[i_0].name, source))) return NULL;
    source = dec_varlong(&packet->entries.base[i_0].value, source);
  }
  return source;
}

char * enc_play_toclient_statistics(char * dest, play_toclient_statistics source) {
  dest = enc_varlong(dest, source.entries.count);
  for(size_t i_0 = 0; i_0 < source.entries.count; ++i_0) {
    dest = enc_string(dest, source.entries.base[i_0].name);
    dest = enc_varlong(dest, source.entries.base[i_0].value);
  }
  return dest;
}

void free_play_toclient_statistics(play_toclient_statistics packet) {
  for(size_t i_0 = 0; i_0 < packet.entries.count; ++i_0) {
    free_string(packet.entries.base[i_0].name);
  }
  free(packet.entries.base);
}

int walk_play_toclient_player_info(char * source, size_t max_len) {
  int ret, size = 0;
  int64_t action;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  max_len -= ret;
  source = dec_varlong(&action, source);
  if((ret = walk_varlong(source, max_len)) < 0) {
      return -1;
  }
  size += ret;
  max_len -= ret;
  int64_t data_count;
  source = dec_varlong(&data_count, source);
  for(size_t i_0 = 0; i_0 < data_count; ++i_0) {
    if(max_len < 16) {
      return -1;
    }
    size += 16;
    source += 16;
    max_len -= 16;
    switch(action) {
      case 0:
        if((ret = walk_string(source, max_len)) < 0) {
          return -1;
        }
        size += ret;
        source += ret;
        max_len -= ret;
        break;
    }
    switch(action) {
      case 0:
        if((ret = walk_varlong(source, max_len)) < 0) {
          return -1;
        }
        size += ret;
        max_len -= ret;
        int64_t properties_count;
        source = dec_varlong(&properties_count, source);
        for(size_t i_3 = 0; i_3 < properties_count; ++i_3) {
          if((ret = walk_string(source, max_len)) < 0) {
            return -1;
          }
          size += ret;
          source += ret;
          max_len -= ret;
          if((ret = walk_string(source, max_len)) < 0) {
            return -1;
          }
          size += ret;
          source += ret;
          max_len -= ret;
          if(max_len < 1) {
              return -1;
          }
          uint8_t signature_opt;
          source = dec_byte(&signature_opt, source);
          size += 1;
          max_len -= 1;
          if(signature_opt) {
            if((ret = walk_string(source, max_len)) < 0) {
              return -1;
            }
            size += ret;
            source += ret;
            max_len -= ret;
          }
        }
        break;
    }
    switch(action) {
      case 1:
      case 0:
        if((ret = walk_varlong(source, max_len)) < 0) {
          return -1;
        }
        size += ret;
        source += ret;
        max_len -= ret;
        break;
    }
    switch(action) {
      case 2:
      case 0:
        if((ret = walk_varlong(source, max_len)) < 0) {
          return -1;
        }
        size += ret;
        source += ret;
        max_len -= ret;
        break;
    }
    switch(action) {
      case 3:
      case 0:
        if(max_len < 1) {
            return -1;
        }
        uint8_t display_name_opt;
        source = dec_byte(&display_name_opt, source);
        size += 1;
        max_len -= 1;
        if(display_name_opt) {
          if((ret = walk_string(source, max_len)) < 0) {
            return -1;
          }
          size += ret;
          source += ret;
          max_len -= ret;
        }
        break;
    }
  }
  return size;
}

size_t size_play_toclient_player_info(play_toclient_player_info packet) {
  size_t size = 0;
  size += size_varlong(packet.action);
  size += size_varlong(packet.data.count);
  for(size_t i_0 = 0; i_0 < packet.data.count; ++i_0) {
    size += 16;
    switch(packet.action) {
      case 0:
        size += size_string(packet.data.base[i_0].name);
        break;
    }
    switch(packet.action) {
      case 0:
        size += size_varlong(packet.data.base[i_0].properties.count);
        for(size_t i_3 = 0; i_3 < packet.data.base[i_0].properties.count; ++i_3) {
          size += size_string(packet.data.base[i_0].properties.base[i_3].name);
          size += size_string(packet.data.base[i_0].properties.base[i_3].value);
          size += 1;
          if(packet.data.base[i_0].properties.base[i_3].signature.opt) {
            size += size_string(packet.data.base[i_0].properties.base[i_3].signature.val);
          }
        }
        break;
    }
    switch(packet.action) {
      case 1:
      case 0:
        size += size_varlong(packet.data.base[i_0].gamemode);
        break;
    }
    switch(packet.action) {
      case 2:
      case 0:
        size += size_varlong(packet.data.base[i_0].ping);
        break;
    }
    switch(packet.action) {
      case 3:
      case 0:
        size += 1;
        if(packet.data.base[i_0].display_name.opt) {
          size += size_string(packet.data.base[i_0].display_name.val);
        }
        break;
    }
  }
  return size;
}

char * dec_play_toclient_player_info(play_toclient_player_info *packet, char * source) {
  source = dec_varlong(&packet->action, source);
  source = dec_varlong(&packet->data.count, source);
  if(!(packet->data.base = malloc(sizeof(*packet->data.base) * packet->data.count))) return NULL;
  for(size_t i_0 = 0; i_0 < packet->data.count; ++i_0) {
    source = dec_uuid(&packet->data.base[i_0].uuid, source);
    switch(packet->action) {
      case 0:
        if(!(source = dec_string(&packet->data.base[i_0].name, source))) return NULL;
        break;
    }
    switch(packet->action) {
      case 0:
        source = dec_varlong(&packet->data.base[i_0].properties.count, source);
        if(!(packet->data.base[i_0].properties.base = malloc(sizeof(*packet->data.base[i_0].properties.base) * packet->data.base[i_0].properties.count))) return NULL;
        for(size_t i_3 = 0; i_3 < packet->data.base[i_0].properties.count; ++i_3) {
          if(!(source = dec_string(&packet->data.base[i_0].properties.base[i_3].name, source))) return NULL;
          if(!(source = dec_string(&packet->data.base[i_0].properties.base[i_3].value, source))) return NULL;
          source = dec_byte(&packet->data.base[i_0].properties.base[i_3].signature.opt, source);
          if(packet->data.base[i_0].properties.base[i_3].signature.opt) {
            if(!(source = dec_string(&packet->data.base[i_0].properties.base[i_3].signature.val, source))) return NULL;
          }
        }
        break;
    }
    switch(packet->action) {
      case 1:
      case 0:
        source = dec_varlong(&packet->data.base[i_0].gamemode, source);
        break;
    }
    switch(packet->action) {
      case 2:
      case 0:
        source = dec_varlong(&packet->data.base[i_0].ping, source);
        break;
    }
    switch(packet->action) {
      case 3:
      case 0:
        source = dec_byte(&packet->data.base[i_0].display_name.opt, source);
        if(packet->data.base[i_0].display_name.opt) {
          if(!(source = dec_string(&packet->data.base[i_0].display_name.val, source))) return NULL;
        }
        break;
    }
  }
  return source;
}

char * enc_play_toclient_player_info(char * dest, play_toclient_player_info source) {
  dest = enc_varlong(dest, source.action);
  dest = enc_varlong(dest, source.data.count);
  for(size_t i_0 = 0; i_0 < source.data.count; ++i_0) {
    dest = enc_uuid(dest, source.data.base[i_0].uuid);
    switch(source.action) {
      case 0:
        dest = enc_string(dest, source.data.base[i_0].name);
        break;
    }
    switch(source.action) {
      case 0:
        dest = enc_varlong(dest, source.data.base[i_0].properties.count);
        for(size_t i_3 = 0; i_3 < source.data.base[i_0].properties.count; ++i_3) {
          dest = enc_string(dest, source.data.base[i_0].properties.base[i_3].name);
          dest = enc_string(dest, source.data.base[i_0].properties.base[i_3].value);
          dest = enc_byte(dest, source.data.base[i_0].properties.base[i_3].signature.opt);
          if(source.data.base[i_0].properties.base[i_3].signature.opt) {
            dest = enc_string(dest, source.data.base[i_0].properties.base[i_3].signature.val);
          }
        }
        break;
    }
    switch(source.action) {
      case 1:
      case 0:
        dest = enc_varlong(dest, source.data.base[i_0].gamemode);
        break;
    }
    switch(source.action) {
      case 2:
      case 0:
        dest = enc_varlong(dest, source.data.base[i_0].ping);
        break;
    }
    switch(source.action) {
      case 3:
      case 0:
        dest = enc_byte(dest, source.data.base[i_0].display_name.opt);
        if(source.data.base[i_0].display_name.opt) {
          dest = enc_string(dest, source.data.base[i_0].display_name.val);
        }
        break;
    }
  }
  return dest;
}

void free_play_toclient_player_info(play_toclient_player_info packet) {
  for(size_t i_0 = 0; i_0 < packet.data.count; ++i_0) {
    switch(packet.action) {
      case 0:
        free_string(packet.data.base[i_0].name);
        break;
    }
    switch(packet.action) {
      case 0:
        for(size_t i_3 = 0; i_3 < packet.data.base[i_0].properties.count; ++i_3) {
          free_string(packet.data.base[i_0].properties.base[i_3].name);
          free_string(packet.data.base[i_0].properties.base[i_3].value);
          if(packet.data.base[i_0].properties.base[i_3].signature.opt) {
            free_string(packet.data.base[i_0].properties.base[i_3].signature.val);
          }
        }
        free(packet.data.base[i_0].properties.base);
        break;
    }
    switch(packet.action) {
      case 3:
      case 0:
        if(packet.data.base[i_0].display_name.opt) {
          free_string(packet.data.base[i_0].display_name.val);
        }
        break;
    }
  }
  free(packet.data.base);
}

int walk_play_toclient_abilities(char * source, size_t max_len) {
  if(max_len < 9) return -1;
  return 9;
}

size_t size_play_toclient_abilities(play_toclient_abilities packet) {
  return 9;
}

char * dec_play_toclient_abilities(play_toclient_abilities *packet, char * source) {
  source = dec_byte(&packet->flags, source);
  source = dec_bef32(&packet->flying_speed, source);
  source = dec_bef32(&packet->walking_speed, source);
  return source;
}

char * enc_play_toclient_abilities(char * dest, play_toclient_abilities source) {
  dest = enc_byte(dest, source.flags);
  dest = enc_bef32(dest, source.flying_speed);
  dest = enc_bef32(dest, source.walking_speed);
  return dest;
}

int walk_play_toclient_tab_complete(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_varlong(source, max_len)) < 0) {
      return -1;
  }
  size += ret;
  max_len -= ret;
  int64_t matches_count;
  source = dec_varlong(&matches_count, source);
  for(size_t i_0 = 0; i_0 < matches_count; ++i_0) {
    if((ret = walk_string(source, max_len)) < 0) {
      return -1;
    }
    size += ret;
    source += ret;
    max_len -= ret;
  }
  return size;
}

size_t size_play_toclient_tab_complete(play_toclient_tab_complete packet) {
  size_t size = 0;
  size += size_varlong(packet.matches.count);
  for(size_t i_0 = 0; i_0 < packet.matches.count; ++i_0) {
    size += size_string(packet.matches.base[i_0]);
  }
  return size;
}

char * dec_play_toclient_tab_complete(play_toclient_tab_complete *packet, char * source) {
  source = dec_varlong(&packet->matches.count, source);
  if(!(packet->matches.base = malloc(sizeof(*packet->matches.base) * packet->matches.count))) return NULL;
  for(size_t i_0 = 0; i_0 < packet->matches.count; ++i_0) {
    if(!(source = dec_string(&packet->matches.base[i_0], source))) return NULL;
  }
  return source;
}

char * enc_play_toclient_tab_complete(char * dest, play_toclient_tab_complete source) {
  dest = enc_varlong(dest, source.matches.count);
  for(size_t i_0 = 0; i_0 < source.matches.count; ++i_0) {
    dest = enc_string(dest, source.matches.base[i_0]);
  }
  return dest;
}

void free_play_toclient_tab_complete(play_toclient_tab_complete packet) {
  for(size_t i_0 = 0; i_0 < packet.matches.count; ++i_0) {
    free_string(packet.matches.base[i_0]);
  }
  free(packet.matches.base);
}

int walk_play_toclient_scoreboard_objective(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_string(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  int8_t action;
  if(max_len < 1) {
    return -1;
  }
  size += 1;
  max_len -= 1;
  source = dec_byte(&action, source);
  switch(action) {
    case 2:
    case 0:
      if((ret = walk_string(source, max_len)) < 0) {
        return -1;
      }
      size += ret;
      source += ret;
      max_len -= ret;
      break;
  }
  switch(action) {
    case 2:
    case 0:
      if((ret = walk_string(source, max_len)) < 0) {
        return -1;
      }
      size += ret;
      source += ret;
      max_len -= ret;
      break;
  }
  return size;
}

size_t size_play_toclient_scoreboard_objective(play_toclient_scoreboard_objective packet) {
  size_t size = 0;
  size += size_string(packet.name);
  size += 1;
  switch(packet.action) {
    case 2:
    case 0:
      size += size_string(packet.display_text);
      break;
  }
  switch(packet.action) {
    case 2:
    case 0:
      size += size_string(packet.type);
      break;
  }
  return size;
}

char * dec_play_toclient_scoreboard_objective(play_toclient_scoreboard_objective *packet, char * source) {
  if(!(source = dec_string(&packet->name, source))) return NULL;
  source = dec_byte(&packet->action, source);
  switch(packet->action) {
    case 2:
    case 0:
      if(!(source = dec_string(&packet->display_text, source))) return NULL;
      break;
  }
  switch(packet->action) {
    case 2:
    case 0:
      if(!(source = dec_string(&packet->type, source))) return NULL;
      break;
  }
  return source;
}

char * enc_play_toclient_scoreboard_objective(char * dest, play_toclient_scoreboard_objective source) {
  dest = enc_string(dest, source.name);
  dest = enc_byte(dest, source.action);
  switch(source.action) {
    case 2:
    case 0:
      dest = enc_string(dest, source.display_text);
      break;
  }
  switch(source.action) {
    case 2:
    case 0:
      dest = enc_string(dest, source.type);
      break;
  }
  return dest;
}

void free_play_toclient_scoreboard_objective(play_toclient_scoreboard_objective packet) {
  free_string(packet.name);
  switch(packet.action) {
    case 2:
    case 0:
      free_string(packet.display_text);
      break;
  }
  switch(packet.action) {
    case 2:
    case 0:
      free_string(packet.type);
      break;
  }
}

int walk_play_toclient_scoreboard_score(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_string(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  int64_t action;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  max_len -= ret;
  source = dec_varlong(&action, source);
  if((ret = walk_string(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  switch(action) {
    case 1:
      // void condition
      break;
    default:
      if((ret = walk_varlong(source, max_len)) < 0) {
        return -1;
      }
      size += ret;
      source += ret;
      max_len -= ret;
  }
  return size;
}

size_t size_play_toclient_scoreboard_score(play_toclient_scoreboard_score packet) {
  size_t size = 0;
  size += size_string(packet.item_name);
  size += size_varlong(packet.action);
  size += size_string(packet.score_name);
  switch(packet.action) {
    case 1:
      // void condition
      break;
    default:
      size += size_varlong(packet.value);
  }
  return size;
}

char * dec_play_toclient_scoreboard_score(play_toclient_scoreboard_score *packet, char * source) {
  if(!(source = dec_string(&packet->item_name, source))) return NULL;
  source = dec_varlong(&packet->action, source);
  if(!(source = dec_string(&packet->score_name, source))) return NULL;
  switch(packet->action) {
    case 1:
      // void condition
      break;
    default:
      source = dec_varlong(&packet->value, source);
  }
  return source;
}

char * enc_play_toclient_scoreboard_score(char * dest, play_toclient_scoreboard_score source) {
  dest = enc_string(dest, source.item_name);
  dest = enc_varlong(dest, source.action);
  dest = enc_string(dest, source.score_name);
  switch(source.action) {
    case 1:
      // void condition
      break;
    default:
      dest = enc_varlong(dest, source.value);
  }
  return dest;
}

void free_play_toclient_scoreboard_score(play_toclient_scoreboard_score packet) {
  free_string(packet.item_name);
  free_string(packet.score_name);
}

int walk_play_toclient_scoreboard_display_objective(char * source, size_t max_len) {
  int ret, size = 0;
  if(max_len < 1) {
    return -1;
  }
  size += 1;
  source += 1;
  max_len -= 1;
  if((ret = walk_string(source, max_len)) < 0) {
    return -1;
  }
  return size + ret;
}

size_t size_play_toclient_scoreboard_display_objective(play_toclient_scoreboard_display_objective packet) {
  size_t size = 0;
  size += 1;
  size += size_string(packet.name);
  return size;
}

char * dec_play_toclient_scoreboard_display_objective(play_toclient_scoreboard_display_objective *packet, char * source) {
  source = dec_byte(&packet->position, source);
  if(!(source = dec_string(&packet->name, source))) return NULL;
  return source;
}

char * enc_play_toclient_scoreboard_display_objective(char * dest, play_toclient_scoreboard_display_objective source) {
  dest = enc_byte(dest, source.position);
  dest = enc_string(dest, source.name);
  return dest;
}

void free_play_toclient_scoreboard_display_objective(play_toclient_scoreboard_display_objective packet) {
  free_string(packet.name);
}

int walk_play_toclient_scoreboard_team(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_string(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  int8_t mode;
  if(max_len < 1) {
    return -1;
  }
  size += 1;
  max_len -= 1;
  source = dec_byte(&mode, source);
  switch(mode) {
    case 2:
    case 0:
      if((ret = walk_string(source, max_len)) < 0) {
        return -1;
      }
      size += ret;
      source += ret;
      max_len -= ret;
      break;
  }
  switch(mode) {
    case 2:
    case 0:
      if((ret = walk_string(source, max_len)) < 0) {
        return -1;
      }
      size += ret;
      source += ret;
      max_len -= ret;
      break;
  }
  switch(mode) {
    case 2:
    case 0:
      if((ret = walk_string(source, max_len)) < 0) {
        return -1;
      }
      size += ret;
      source += ret;
      max_len -= ret;
      break;
  }
  switch(mode) {
    case 2:
    case 0:
      if(max_len < 1) {
        return -1;
      }
      size += 1;
      source += 1;
      max_len -= 1;
      break;
  }
  switch(mode) {
    case 2:
    case 0:
      if((ret = walk_string(source, max_len)) < 0) {
        return -1;
      }
      size += ret;
      source += ret;
      max_len -= ret;
      break;
  }
  switch(mode) {
    case 2:
    case 0:
      if(max_len < 1) {
        return -1;
      }
      size += 1;
      source += 1;
      max_len -= 1;
      break;
  }
  switch(mode) {
    case 4:
    case 3:
    case 0:
      if((ret = walk_varlong(source, max_len)) < 0) {
          return -1;
      }
      size += ret;
      max_len -= ret;
      int64_t players_count;
      source = dec_varlong(&players_count, source);
      for(size_t i_1 = 0; i_1 < players_count; ++i_1) {
        if((ret = walk_string(source, max_len)) < 0) {
          return -1;
        }
        size += ret;
        source += ret;
        max_len -= ret;
      }
      break;
  }
  return size;
}

size_t size_play_toclient_scoreboard_team(play_toclient_scoreboard_team packet) {
  size_t size = 0;
  size += size_string(packet.team);
  size += 1;
  switch(packet.mode) {
    case 2:
    case 0:
      size += size_string(packet.name);
      break;
  }
  switch(packet.mode) {
    case 2:
    case 0:
      size += size_string(packet.prefix);
      break;
  }
  switch(packet.mode) {
    case 2:
    case 0:
      size += size_string(packet.suffix);
      break;
  }
  switch(packet.mode) {
    case 2:
    case 0:
      size += 1;
      break;
  }
  switch(packet.mode) {
    case 2:
    case 0:
      size += size_string(packet.name_tag_visibility);
      break;
  }
  switch(packet.mode) {
    case 2:
    case 0:
      size += 1;
      break;
  }
  switch(packet.mode) {
    case 4:
    case 3:
    case 0:
      size += size_varlong(packet.players.count);
      for(size_t i_1 = 0; i_1 < packet.players.count; ++i_1) {
        size += size_string(packet.players.base[i_1]);
      }
      break;
  }
  return size;
}

char * dec_play_toclient_scoreboard_team(play_toclient_scoreboard_team *packet, char * source) {
  if(!(source = dec_string(&packet->team, source))) return NULL;
  source = dec_byte(&packet->mode, source);
  switch(packet->mode) {
    case 2:
    case 0:
      if(!(source = dec_string(&packet->name, source))) return NULL;
      break;
  }
  switch(packet->mode) {
    case 2:
    case 0:
      if(!(source = dec_string(&packet->prefix, source))) return NULL;
      break;
  }
  switch(packet->mode) {
    case 2:
    case 0:
      if(!(source = dec_string(&packet->suffix, source))) return NULL;
      break;
  }
  switch(packet->mode) {
    case 2:
    case 0:
      source = dec_byte(&packet->friendly_fire, source);
      break;
  }
  switch(packet->mode) {
    case 2:
    case 0:
      if(!(source = dec_string(&packet->name_tag_visibility, source))) return NULL;
      break;
  }
  switch(packet->mode) {
    case 2:
    case 0:
      source = dec_byte(&packet->color, source);
      break;
  }
  switch(packet->mode) {
    case 4:
    case 3:
    case 0:
      source = dec_varlong(&packet->players.count, source);
      if(!(packet->players.base = malloc(sizeof(*packet->players.base) * packet->players.count))) return NULL;
      for(size_t i_1 = 0; i_1 < packet->players.count; ++i_1) {
        if(!(source = dec_string(&packet->players.base[i_1], source))) return NULL;
      }
      break;
  }
  return source;
}

char * enc_play_toclient_scoreboard_team(char * dest, play_toclient_scoreboard_team source) {
  dest = enc_string(dest, source.team);
  dest = enc_byte(dest, source.mode);
  switch(source.mode) {
    case 2:
    case 0:
      dest = enc_string(dest, source.name);
      break;
  }
  switch(source.mode) {
    case 2:
    case 0:
      dest = enc_string(dest, source.prefix);
      break;
  }
  switch(source.mode) {
    case 2:
    case 0:
      dest = enc_string(dest, source.suffix);
      break;
  }
  switch(source.mode) {
    case 2:
    case 0:
      dest = enc_byte(dest, source.friendly_fire);
      break;
  }
  switch(source.mode) {
    case 2:
    case 0:
      dest = enc_string(dest, source.name_tag_visibility);
      break;
  }
  switch(source.mode) {
    case 2:
    case 0:
      dest = enc_byte(dest, source.color);
      break;
  }
  switch(source.mode) {
    case 4:
    case 3:
    case 0:
      dest = enc_varlong(dest, source.players.count);
      for(size_t i_1 = 0; i_1 < source.players.count; ++i_1) {
        dest = enc_string(dest, source.players.base[i_1]);
      }
      break;
  }
  return dest;
}

void free_play_toclient_scoreboard_team(play_toclient_scoreboard_team packet) {
  free_string(packet.team);
  switch(packet.mode) {
    case 2:
    case 0:
      free_string(packet.name);
      break;
  }
  switch(packet.mode) {
    case 2:
    case 0:
      free_string(packet.prefix);
      break;
  }
  switch(packet.mode) {
    case 2:
    case 0:
      free_string(packet.suffix);
      break;
  }
  switch(packet.mode) {
    case 2:
    case 0:
      free_string(packet.name_tag_visibility);
      break;
  }
  switch(packet.mode) {
    case 4:
    case 3:
    case 0:
      for(size_t i_1 = 0; i_1 < packet.players.count; ++i_1) {
        free_string(packet.players.base[i_1]);
      }
      free(packet.players.base);
      break;
  }
}

int walk_play_toclient_custom_payload(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_string(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  ret = max_len;
  return size + ret;
}

size_t size_play_toclient_custom_payload(play_toclient_custom_payload packet) {
  size_t size = 0;
  size += size_string(packet.channel);
  size += packet.data.len;
  return size;
}

char * dec_play_toclient_custom_payload(play_toclient_custom_payload *packet, char * source, size_t total_size) {
  char * endptr = source + total_size;
  if(!(source = dec_string(&packet->channel, source))) return NULL;
  source = dec_buffer(&packet->data, source, endptr - source);
  return source;
}

char * enc_play_toclient_custom_payload(char * dest, play_toclient_custom_payload source) {
  dest = enc_string(dest, source.channel);
  dest = enc_buffer(dest, source.data);
  return dest;
}

void free_play_toclient_custom_payload(play_toclient_custom_payload packet) {
  free_string(packet.channel);
  free(packet.data.base);
}

int walk_play_toclient_kick_disconnect(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_string(source, max_len)) < 0) {
    return -1;
  }
  return size + ret;
}

size_t size_play_toclient_kick_disconnect(play_toclient_kick_disconnect packet) {
  size_t size = 0;
  size += size_string(packet.reason);
  return size;
}

char * dec_play_toclient_kick_disconnect(play_toclient_kick_disconnect *packet, char * source) {
  if(!(source = dec_string(&packet->reason, source))) return NULL;
  return source;
}

char * enc_play_toclient_kick_disconnect(char * dest, play_toclient_kick_disconnect source) {
  dest = enc_string(dest, source.reason);
  return dest;
}

void free_play_toclient_kick_disconnect(play_toclient_kick_disconnect packet) {
  free_string(packet.reason);
}

int walk_play_toclient_difficulty(char * source, size_t max_len) {
  if(max_len < 1) return -1;
  return 1;
}

size_t size_play_toclient_difficulty(play_toclient_difficulty packet) {
  return 1;
}

char * dec_play_toclient_difficulty(play_toclient_difficulty *packet, char * source) {
  source = dec_byte(&packet->difficulty, source);
  return source;
}

char * enc_play_toclient_difficulty(char * dest, play_toclient_difficulty source) {
  dest = enc_byte(dest, source.difficulty);
  return dest;
}

int walk_play_toclient_combat_event(char * source, size_t max_len) {
  int ret, size = 0;
  int64_t event;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  max_len -= ret;
  source = dec_varlong(&event, source);
  switch(event) {
    case 1:
      if((ret = walk_varlong(source, max_len)) < 0) {
        return -1;
      }
      size += ret;
      source += ret;
      max_len -= ret;
      break;
  }
  switch(event) {
    case 2:
      if((ret = walk_varlong(source, max_len)) < 0) {
        return -1;
      }
      size += ret;
      source += ret;
      max_len -= ret;
      break;
  }
  switch(event) {
    case 2:
    case 1:
      if(max_len < 4) {
        return -1;
      }
      size += 4;
      source += 4;
      max_len -= 4;
      break;
  }
  switch(event) {
    case 2:
      if((ret = walk_string(source, max_len)) < 0) {
        return -1;
      }
      size += ret;
      source += ret;
      max_len -= ret;
      break;
  }
  return size;
}

size_t size_play_toclient_combat_event(play_toclient_combat_event packet) {
  size_t size = 0;
  size += size_varlong(packet.event);
  switch(packet.event) {
    case 1:
      size += size_varlong(packet.duration);
      break;
  }
  switch(packet.event) {
    case 2:
      size += size_varlong(packet.player_id);
      break;
  }
  switch(packet.event) {
    case 2:
    case 1:
      size += 4;
      break;
  }
  switch(packet.event) {
    case 2:
      size += size_string(packet.message);
      break;
  }
  return size;
}

char * dec_play_toclient_combat_event(play_toclient_combat_event *packet, char * source) {
  source = dec_varlong(&packet->event, source);
  switch(packet->event) {
    case 1:
      source = dec_varlong(&packet->duration, source);
      break;
  }
  switch(packet->event) {
    case 2:
      source = dec_varlong(&packet->player_id, source);
      break;
  }
  switch(packet->event) {
    case 2:
    case 1:
      source = dec_be32(&packet->entity_id, source);
      break;
  }
  switch(packet->event) {
    case 2:
      if(!(source = dec_string(&packet->message, source))) return NULL;
      break;
  }
  return source;
}

char * enc_play_toclient_combat_event(char * dest, play_toclient_combat_event source) {
  dest = enc_varlong(dest, source.event);
  switch(source.event) {
    case 1:
      dest = enc_varlong(dest, source.duration);
      break;
  }
  switch(source.event) {
    case 2:
      dest = enc_varlong(dest, source.player_id);
      break;
  }
  switch(source.event) {
    case 2:
    case 1:
      dest = enc_be32(dest, source.entity_id);
      break;
  }
  switch(source.event) {
    case 2:
      dest = enc_string(dest, source.message);
      break;
  }
  return dest;
}

void free_play_toclient_combat_event(play_toclient_combat_event packet) {
  switch(packet.event) {
    case 2:
      free_string(packet.message);
      break;
  }
}

int walk_play_toclient_camera(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  return size + ret;
}

size_t size_play_toclient_camera(play_toclient_camera packet) {
  size_t size = 0;
  size += size_varlong(packet.camera_id);
  return size;
}

char * dec_play_toclient_camera(play_toclient_camera *packet, char * source) {
  source = dec_varlong(&packet->camera_id, source);
  return source;
}

char * enc_play_toclient_camera(char * dest, play_toclient_camera source) {
  dest = enc_varlong(dest, source.camera_id);
  return dest;
}

int walk_play_toclient_world_border(char * source, size_t max_len) {
  int ret, size = 0;
  int64_t action;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  max_len -= ret;
  source = dec_varlong(&action, source);
  switch(action) {
    case 0:
      if(max_len < 8) {
        return -1;
      }
      size += 8;
      source += 8;
      max_len -= 8;
      break;
  }
  switch(action) {
    case 3:
    case 2:
      if(max_len < 8) {
        return -1;
      }
      size += 8;
      source += 8;
      max_len -= 8;
      break;
  }
  switch(action) {
    case 3:
    case 2:
      if(max_len < 8) {
        return -1;
      }
      size += 8;
      source += 8;
      max_len -= 8;
      break;
  }
  switch(action) {
    case 3:
    case 1:
      if(max_len < 8) {
        return -1;
      }
      size += 8;
      source += 8;
      max_len -= 8;
      break;
  }
  switch(action) {
    case 3:
    case 1:
      if(max_len < 8) {
        return -1;
      }
      size += 8;
      source += 8;
      max_len -= 8;
      break;
  }
  switch(action) {
    case 3:
    case 1:
      if((ret = walk_varlong(source, max_len)) < 0) {
        return -1;
      }
      size += ret;
      source += ret;
      max_len -= ret;
      break;
  }
  switch(action) {
    case 3:
      if((ret = walk_varlong(source, max_len)) < 0) {
        return -1;
      }
      size += ret;
      source += ret;
      max_len -= ret;
      break;
  }
  switch(action) {
    case 4:
    case 3:
      if((ret = walk_varlong(source, max_len)) < 0) {
        return -1;
      }
      size += ret;
      source += ret;
      max_len -= ret;
      break;
  }
  switch(action) {
    case 5:
    case 3:
      if((ret = walk_varlong(source, max_len)) < 0) {
        return -1;
      }
      size += ret;
      source += ret;
      max_len -= ret;
      break;
  }
  return size;
}

size_t size_play_toclient_world_border(play_toclient_world_border packet) {
  size_t size = 0;
  size += size_varlong(packet.action);
  switch(packet.action) {
    case 0:
      size += 8;
      break;
  }
  switch(packet.action) {
    case 3:
    case 2:
      size += 8;
      break;
  }
  switch(packet.action) {
    case 3:
    case 2:
      size += 8;
      break;
  }
  switch(packet.action) {
    case 3:
    case 1:
      size += 8;
      break;
  }
  switch(packet.action) {
    case 3:
    case 1:
      size += 8;
      break;
  }
  switch(packet.action) {
    case 3:
    case 1:
      size += size_varlong(packet.speed);
      break;
  }
  switch(packet.action) {
    case 3:
      size += size_varlong(packet.portal_boundary);
      break;
  }
  switch(packet.action) {
    case 4:
    case 3:
      size += size_varlong(packet.warning_time);
      break;
  }
  switch(packet.action) {
    case 5:
    case 3:
      size += size_varlong(packet.warning_blocks);
      break;
  }
  return size;
}

char * dec_play_toclient_world_border(play_toclient_world_border *packet, char * source) {
  source = dec_varlong(&packet->action, source);
  switch(packet->action) {
    case 0:
      source = dec_bef64(&packet->radius, source);
      break;
  }
  switch(packet->action) {
    case 3:
    case 2:
      source = dec_bef64(&packet->x, source);
      break;
  }
  switch(packet->action) {
    case 3:
    case 2:
      source = dec_bef64(&packet->z, source);
      break;
  }
  switch(packet->action) {
    case 3:
    case 1:
      source = dec_bef64(&packet->old_radius, source);
      break;
  }
  switch(packet->action) {
    case 3:
    case 1:
      source = dec_bef64(&packet->new_radius, source);
      break;
  }
  switch(packet->action) {
    case 3:
    case 1:
      source = dec_varlong(&packet->speed, source);
      break;
  }
  switch(packet->action) {
    case 3:
      source = dec_varlong(&packet->portal_boundary, source);
      break;
  }
  switch(packet->action) {
    case 4:
    case 3:
      source = dec_varlong(&packet->warning_time, source);
      break;
  }
  switch(packet->action) {
    case 5:
    case 3:
      source = dec_varlong(&packet->warning_blocks, source);
      break;
  }
  return source;
}

char * enc_play_toclient_world_border(char * dest, play_toclient_world_border source) {
  dest = enc_varlong(dest, source.action);
  switch(source.action) {
    case 0:
      dest = enc_bef64(dest, source.radius);
      break;
  }
  switch(source.action) {
    case 3:
    case 2:
      dest = enc_bef64(dest, source.x);
      break;
  }
  switch(source.action) {
    case 3:
    case 2:
      dest = enc_bef64(dest, source.z);
      break;
  }
  switch(source.action) {
    case 3:
    case 1:
      dest = enc_bef64(dest, source.old_radius);
      break;
  }
  switch(source.action) {
    case 3:
    case 1:
      dest = enc_bef64(dest, source.new_radius);
      break;
  }
  switch(source.action) {
    case 3:
    case 1:
      dest = enc_varlong(dest, source.speed);
      break;
  }
  switch(source.action) {
    case 3:
      dest = enc_varlong(dest, source.portal_boundary);
      break;
  }
  switch(source.action) {
    case 4:
    case 3:
      dest = enc_varlong(dest, source.warning_time);
      break;
  }
  switch(source.action) {
    case 5:
    case 3:
      dest = enc_varlong(dest, source.warning_blocks);
      break;
  }
  return dest;
}

int walk_play_toclient_title(char * source, size_t max_len) {
  int ret, size = 0;
  int64_t action;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  max_len -= ret;
  source = dec_varlong(&action, source);
  switch(action) {
    case 1:
    case 0:
      if((ret = walk_string(source, max_len)) < 0) {
        return -1;
      }
      size += ret;
      source += ret;
      max_len -= ret;
      break;
  }
  switch(action) {
    case 2:
      if(max_len < 4) {
        return -1;
      }
      size += 4;
      source += 4;
      max_len -= 4;
      break;
  }
  switch(action) {
    case 2:
      if(max_len < 4) {
        return -1;
      }
      size += 4;
      source += 4;
      max_len -= 4;
      break;
  }
  switch(action) {
    case 2:
      if(max_len < 4) {
        return -1;
      }
      size += 4;
      source += 4;
      max_len -= 4;
      break;
  }
  return size;
}

size_t size_play_toclient_title(play_toclient_title packet) {
  size_t size = 0;
  size += size_varlong(packet.action);
  switch(packet.action) {
    case 1:
    case 0:
      size += size_string(packet.text);
      break;
  }
  switch(packet.action) {
    case 2:
      size += 4;
      break;
  }
  switch(packet.action) {
    case 2:
      size += 4;
      break;
  }
  switch(packet.action) {
    case 2:
      size += 4;
      break;
  }
  return size;
}

char * dec_play_toclient_title(play_toclient_title *packet, char * source) {
  source = dec_varlong(&packet->action, source);
  switch(packet->action) {
    case 1:
    case 0:
      if(!(source = dec_string(&packet->text, source))) return NULL;
      break;
  }
  switch(packet->action) {
    case 2:
      source = dec_be32(&packet->fade_in, source);
      break;
  }
  switch(packet->action) {
    case 2:
      source = dec_be32(&packet->stay, source);
      break;
  }
  switch(packet->action) {
    case 2:
      source = dec_be32(&packet->fade_out, source);
      break;
  }
  return source;
}

char * enc_play_toclient_title(char * dest, play_toclient_title source) {
  dest = enc_varlong(dest, source.action);
  switch(source.action) {
    case 1:
    case 0:
      dest = enc_string(dest, source.text);
      break;
  }
  switch(source.action) {
    case 2:
      dest = enc_be32(dest, source.fade_in);
      break;
  }
  switch(source.action) {
    case 2:
      dest = enc_be32(dest, source.stay);
      break;
  }
  switch(source.action) {
    case 2:
      dest = enc_be32(dest, source.fade_out);
      break;
  }
  return dest;
}

void free_play_toclient_title(play_toclient_title packet) {
  switch(packet.action) {
    case 1:
    case 0:
      free_string(packet.text);
      break;
  }
}

int walk_play_toclient_set_compression(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  return size + ret;
}

size_t size_play_toclient_set_compression(play_toclient_set_compression packet) {
  size_t size = 0;
  size += size_varlong(packet.threshold);
  return size;
}

char * dec_play_toclient_set_compression(play_toclient_set_compression *packet, char * source) {
  source = dec_varlong(&packet->threshold, source);
  return source;
}

char * enc_play_toclient_set_compression(char * dest, play_toclient_set_compression source) {
  dest = enc_varlong(dest, source.threshold);
  return dest;
}

int walk_play_toclient_playerlist_header(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_string(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if((ret = walk_string(source, max_len)) < 0) {
    return -1;
  }
  return size + ret;
}

size_t size_play_toclient_playerlist_header(play_toclient_playerlist_header packet) {
  size_t size = 0;
  size += size_string(packet.header);
  size += size_string(packet.footer);
  return size;
}

char * dec_play_toclient_playerlist_header(play_toclient_playerlist_header *packet, char * source) {
  if(!(source = dec_string(&packet->header, source))) return NULL;
  if(!(source = dec_string(&packet->footer, source))) return NULL;
  return source;
}

char * enc_play_toclient_playerlist_header(char * dest, play_toclient_playerlist_header source) {
  dest = enc_string(dest, source.header);
  dest = enc_string(dest, source.footer);
  return dest;
}

void free_play_toclient_playerlist_header(play_toclient_playerlist_header packet) {
  free_string(packet.header);
  free_string(packet.footer);
}

int walk_play_toclient_resource_pack_send(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_string(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if((ret = walk_string(source, max_len)) < 0) {
    return -1;
  }
  return size + ret;
}

size_t size_play_toclient_resource_pack_send(play_toclient_resource_pack_send packet) {
  size_t size = 0;
  size += size_string(packet.url);
  size += size_string(packet.hash);
  return size;
}

char * dec_play_toclient_resource_pack_send(play_toclient_resource_pack_send *packet, char * source) {
  if(!(source = dec_string(&packet->url, source))) return NULL;
  if(!(source = dec_string(&packet->hash, source))) return NULL;
  return source;
}

char * enc_play_toclient_resource_pack_send(char * dest, play_toclient_resource_pack_send source) {
  dest = enc_string(dest, source.url);
  dest = enc_string(dest, source.hash);
  return dest;
}

void free_play_toclient_resource_pack_send(play_toclient_resource_pack_send packet) {
  free_string(packet.url);
  free_string(packet.hash);
}

int walk_play_toclient_update_entity_nbt(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if((ret = walk_nbt(source, max_len)) < 0) {
    return -1;
  }
  return size + ret;
}

size_t size_play_toclient_update_entity_nbt(play_toclient_update_entity_nbt packet) {
  size_t size = 0;
  size += size_varlong(packet.entity_id);
  size += size_nbt(packet.tag);
  return size;
}

char * dec_play_toclient_update_entity_nbt(play_toclient_update_entity_nbt *packet, char * source) {
  source = dec_varlong(&packet->entity_id, source);
  if(!(source = dec_nbt(&packet->tag, source))) return NULL;
  return source;
}

char * enc_play_toclient_update_entity_nbt(char * dest, play_toclient_update_entity_nbt source) {
  dest = enc_varlong(dest, source.entity_id);
  dest = enc_nbt(dest, source.tag);
  return dest;
}

void free_play_toclient_update_entity_nbt(play_toclient_update_entity_nbt packet) {
  free_nbt(packet.tag);
}

int walk_play_toserver_keep_alive(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  return size + ret;
}

size_t size_play_toserver_keep_alive(play_toserver_keep_alive packet) {
  size_t size = 0;
  size += size_varlong(packet.keep_alive_id);
  return size;
}

char * dec_play_toserver_keep_alive(play_toserver_keep_alive *packet, char * source) {
  source = dec_varlong(&packet->keep_alive_id, source);
  return source;
}

char * enc_play_toserver_keep_alive(char * dest, play_toserver_keep_alive source) {
  dest = enc_varlong(dest, source.keep_alive_id);
  return dest;
}

int walk_play_toserver_chat(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_string(source, max_len)) < 0) {
    return -1;
  }
  return size + ret;
}

size_t size_play_toserver_chat(play_toserver_chat packet) {
  size_t size = 0;
  size += size_string(packet.message);
  return size;
}

char * dec_play_toserver_chat(play_toserver_chat *packet, char * source) {
  if(!(source = dec_string(&packet->message, source))) return NULL;
  return source;
}

char * enc_play_toserver_chat(char * dest, play_toserver_chat source) {
  dest = enc_string(dest, source.message);
  return dest;
}

void free_play_toserver_chat(play_toserver_chat packet) {
  free_string(packet.message);
}

int walk_play_toserver_use_entity(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  int64_t mouse;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  max_len -= ret;
  source = dec_varlong(&mouse, source);
  switch(mouse) {
    case 2:
      if(max_len < 4) {
        return -1;
      }
      size += 4;
      source += 4;
      max_len -= 4;
      break;
  }
  switch(mouse) {
    case 2:
      if(max_len < 4) {
        return -1;
      }
      size += 4;
      source += 4;
      max_len -= 4;
      break;
  }
  switch(mouse) {
    case 2:
      if(max_len < 4) {
        return -1;
      }
      size += 4;
      source += 4;
      max_len -= 4;
      break;
  }
  return size;
}

size_t size_play_toserver_use_entity(play_toserver_use_entity packet) {
  size_t size = 0;
  size += size_varlong(packet.target);
  size += size_varlong(packet.mouse);
  switch(packet.mouse) {
    case 2:
      size += 4;
      break;
  }
  switch(packet.mouse) {
    case 2:
      size += 4;
      break;
  }
  switch(packet.mouse) {
    case 2:
      size += 4;
      break;
  }
  return size;
}

char * dec_play_toserver_use_entity(play_toserver_use_entity *packet, char * source) {
  source = dec_varlong(&packet->target, source);
  source = dec_varlong(&packet->mouse, source);
  switch(packet->mouse) {
    case 2:
      source = dec_bef32(&packet->x, source);
      break;
  }
  switch(packet->mouse) {
    case 2:
      source = dec_bef32(&packet->y, source);
      break;
  }
  switch(packet->mouse) {
    case 2:
      source = dec_bef32(&packet->z, source);
      break;
  }
  return source;
}

char * enc_play_toserver_use_entity(char * dest, play_toserver_use_entity source) {
  dest = enc_varlong(dest, source.target);
  dest = enc_varlong(dest, source.mouse);
  switch(source.mouse) {
    case 2:
      dest = enc_bef32(dest, source.x);
      break;
  }
  switch(source.mouse) {
    case 2:
      dest = enc_bef32(dest, source.y);
      break;
  }
  switch(source.mouse) {
    case 2:
      dest = enc_bef32(dest, source.z);
      break;
  }
  return dest;
}

int walk_play_toserver_flying(char * source, size_t max_len) {
  if(max_len < 1) return -1;
  return 1;
}

size_t size_play_toserver_flying(play_toserver_flying packet) {
  return 1;
}

char * dec_play_toserver_flying(play_toserver_flying *packet, char * source) {
  source = dec_byte(&packet->on_ground, source);
  return source;
}

char * enc_play_toserver_flying(char * dest, play_toserver_flying source) {
  dest = enc_byte(dest, source.on_ground);
  return dest;
}

int walk_play_toserver_position(char * source, size_t max_len) {
  if(max_len < 25) return -1;
  return 25;
}

size_t size_play_toserver_position(play_toserver_position packet) {
  return 25;
}

char * dec_play_toserver_position(play_toserver_position *packet, char * source) {
  source = dec_bef64(&packet->x, source);
  source = dec_bef64(&packet->y, source);
  source = dec_bef64(&packet->z, source);
  source = dec_byte(&packet->on_ground, source);
  return source;
}

char * enc_play_toserver_position(char * dest, play_toserver_position source) {
  dest = enc_bef64(dest, source.x);
  dest = enc_bef64(dest, source.y);
  dest = enc_bef64(dest, source.z);
  dest = enc_byte(dest, source.on_ground);
  return dest;
}

int walk_play_toserver_look(char * source, size_t max_len) {
  if(max_len < 9) return -1;
  return 9;
}

size_t size_play_toserver_look(play_toserver_look packet) {
  return 9;
}

char * dec_play_toserver_look(play_toserver_look *packet, char * source) {
  source = dec_bef32(&packet->yaw, source);
  source = dec_bef32(&packet->pitch, source);
  source = dec_byte(&packet->on_ground, source);
  return source;
}

char * enc_play_toserver_look(char * dest, play_toserver_look source) {
  dest = enc_bef32(dest, source.yaw);
  dest = enc_bef32(dest, source.pitch);
  dest = enc_byte(dest, source.on_ground);
  return dest;
}

int walk_play_toserver_position_look(char * source, size_t max_len) {
  if(max_len < 33) return -1;
  return 33;
}

size_t size_play_toserver_position_look(play_toserver_position_look packet) {
  return 33;
}

char * dec_play_toserver_position_look(play_toserver_position_look *packet, char * source) {
  source = dec_bef64(&packet->x, source);
  source = dec_bef64(&packet->y, source);
  source = dec_bef64(&packet->z, source);
  source = dec_bef32(&packet->yaw, source);
  source = dec_bef32(&packet->pitch, source);
  source = dec_byte(&packet->on_ground, source);
  return source;
}

char * enc_play_toserver_position_look(char * dest, play_toserver_position_look source) {
  dest = enc_bef64(dest, source.x);
  dest = enc_bef64(dest, source.y);
  dest = enc_bef64(dest, source.z);
  dest = enc_bef32(dest, source.yaw);
  dest = enc_bef32(dest, source.pitch);
  dest = enc_byte(dest, source.on_ground);
  return dest;
}

int walk_play_toserver_block_dig(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if(max_len < 9) {
    return -1;
  }
  return size + 9;
}

size_t size_play_toserver_block_dig(play_toserver_block_dig packet) {
  size_t size = 0;
  size += size_varlong(packet.status);
  return size + 9;
}

char * dec_play_toserver_block_dig(play_toserver_block_dig *packet, char * source) {
  source = dec_varlong(&packet->status, source);
  source = dec_position(&packet->location, source);
  source = dec_byte(&packet->face, source);
  return source;
}

char * enc_play_toserver_block_dig(char * dest, play_toserver_block_dig source) {
  dest = enc_varlong(dest, source.status);
  dest = enc_position(dest, source.location);
  dest = enc_byte(dest, source.face);
  return dest;
}

int walk_play_toserver_block_place(char * source, size_t max_len) {
  int ret, size = 0;
  if(max_len < 9) {
    return -1;
  }
  size += 9;
  source += 9;
  max_len -= 9;
  if((ret = walk_slot(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if(max_len < 3) {
    return -1;
  }
  return size + 3;
}

size_t size_play_toserver_block_place(play_toserver_block_place packet) {
  size_t size = 0;
  size += 9;
  size += size_slot(packet.held_item);
  return size + 3;
}

char * dec_play_toserver_block_place(play_toserver_block_place *packet, char * source) {
  source = dec_position(&packet->location, source);
  source = dec_byte(&packet->direction, source);
  if(!(source = dec_slot(&packet->held_item, source))) return NULL;
  source = dec_byte(&packet->cursor_x, source);
  source = dec_byte(&packet->cursor_y, source);
  source = dec_byte(&packet->cursor_z, source);
  return source;
}

char * enc_play_toserver_block_place(char * dest, play_toserver_block_place source) {
  dest = enc_position(dest, source.location);
  dest = enc_byte(dest, source.direction);
  dest = enc_slot(dest, source.held_item);
  dest = enc_byte(dest, source.cursor_x);
  dest = enc_byte(dest, source.cursor_y);
  dest = enc_byte(dest, source.cursor_z);
  return dest;
}

void free_play_toserver_block_place(play_toserver_block_place packet) {
  free_slot(packet.held_item);
}

int walk_play_toserver_held_item_slot(char * source, size_t max_len) {
  if(max_len < 2) return -1;
  return 2;
}

size_t size_play_toserver_held_item_slot(play_toserver_held_item_slot packet) {
  return 2;
}

char * dec_play_toserver_held_item_slot(play_toserver_held_item_slot *packet, char * source) {
  source = dec_be16(&packet->slot_id, source);
  return source;
}

char * enc_play_toserver_held_item_slot(char * dest, play_toserver_held_item_slot source) {
  dest = enc_be16(dest, source.slot_id);
  return dest;
}

int walk_play_toserver_entity_action(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  return size + ret;
}

size_t size_play_toserver_entity_action(play_toserver_entity_action packet) {
  size_t size = 0;
  size += size_varlong(packet.entity_id);
  size += size_varlong(packet.action_id);
  size += size_varlong(packet.jump_boost);
  return size;
}

char * dec_play_toserver_entity_action(play_toserver_entity_action *packet, char * source) {
  source = dec_varlong(&packet->entity_id, source);
  source = dec_varlong(&packet->action_id, source);
  source = dec_varlong(&packet->jump_boost, source);
  return source;
}

char * enc_play_toserver_entity_action(char * dest, play_toserver_entity_action source) {
  dest = enc_varlong(dest, source.entity_id);
  dest = enc_varlong(dest, source.action_id);
  dest = enc_varlong(dest, source.jump_boost);
  return dest;
}

int walk_play_toserver_steer_vehicle(char * source, size_t max_len) {
  if(max_len < 9) return -1;
  return 9;
}

size_t size_play_toserver_steer_vehicle(play_toserver_steer_vehicle packet) {
  return 9;
}

char * dec_play_toserver_steer_vehicle(play_toserver_steer_vehicle *packet, char * source) {
  source = dec_bef32(&packet->sideways, source);
  source = dec_bef32(&packet->forward, source);
  source = dec_byte(&packet->jump, source);
  return source;
}

char * enc_play_toserver_steer_vehicle(char * dest, play_toserver_steer_vehicle source) {
  dest = enc_bef32(dest, source.sideways);
  dest = enc_bef32(dest, source.forward);
  dest = enc_byte(dest, source.jump);
  return dest;
}

int walk_play_toserver_close_window(char * source, size_t max_len) {
  if(max_len < 1) return -1;
  return 1;
}

size_t size_play_toserver_close_window(play_toserver_close_window packet) {
  return 1;
}

char * dec_play_toserver_close_window(play_toserver_close_window *packet, char * source) {
  source = dec_byte(&packet->window_id, source);
  return source;
}

char * enc_play_toserver_close_window(char * dest, play_toserver_close_window source) {
  dest = enc_byte(dest, source.window_id);
  return dest;
}

int walk_play_toserver_window_click(char * source, size_t max_len) {
  int ret, size = 0;
  if(max_len < 7) {
    return -1;
  }
  size += 7;
  source += 7;
  max_len -= 7;
  if((ret = walk_slot(source, max_len)) < 0) {
    return -1;
  }
  return size + ret;
}

size_t size_play_toserver_window_click(play_toserver_window_click packet) {
  size_t size = 0;
  size += 7;
  size += size_slot(packet.item);
  return size;
}

char * dec_play_toserver_window_click(play_toserver_window_click *packet, char * source) {
  source = dec_byte(&packet->window_id, source);
  source = dec_be16(&packet->slot, source);
  source = dec_byte(&packet->mouse_button, source);
  source = dec_be16(&packet->action, source);
  source = dec_byte(&packet->mode, source);
  if(!(source = dec_slot(&packet->item, source))) return NULL;
  return source;
}

char * enc_play_toserver_window_click(char * dest, play_toserver_window_click source) {
  dest = enc_byte(dest, source.window_id);
  dest = enc_be16(dest, source.slot);
  dest = enc_byte(dest, source.mouse_button);
  dest = enc_be16(dest, source.action);
  dest = enc_byte(dest, source.mode);
  dest = enc_slot(dest, source.item);
  return dest;
}

void free_play_toserver_window_click(play_toserver_window_click packet) {
  free_slot(packet.item);
}

int walk_play_toserver_transaction(char * source, size_t max_len) {
  if(max_len < 4) return -1;
  return 4;
}

size_t size_play_toserver_transaction(play_toserver_transaction packet) {
  return 4;
}

char * dec_play_toserver_transaction(play_toserver_transaction *packet, char * source) {
  source = dec_byte(&packet->window_id, source);
  source = dec_be16(&packet->action, source);
  source = dec_byte(&packet->accepted, source);
  return source;
}

char * enc_play_toserver_transaction(char * dest, play_toserver_transaction source) {
  dest = enc_byte(dest, source.window_id);
  dest = enc_be16(dest, source.action);
  dest = enc_byte(dest, source.accepted);
  return dest;
}

int walk_play_toserver_set_creative_slot(char * source, size_t max_len) {
  int ret, size = 0;
  if(max_len < 2) {
    return -1;
  }
  size += 2;
  source += 2;
  max_len -= 2;
  if((ret = walk_slot(source, max_len)) < 0) {
    return -1;
  }
  return size + ret;
}

size_t size_play_toserver_set_creative_slot(play_toserver_set_creative_slot packet) {
  size_t size = 0;
  size += 2;
  size += size_slot(packet.item);
  return size;
}

char * dec_play_toserver_set_creative_slot(play_toserver_set_creative_slot *packet, char * source) {
  source = dec_be16(&packet->slot, source);
  if(!(source = dec_slot(&packet->item, source))) return NULL;
  return source;
}

char * enc_play_toserver_set_creative_slot(char * dest, play_toserver_set_creative_slot source) {
  dest = enc_be16(dest, source.slot);
  dest = enc_slot(dest, source.item);
  return dest;
}

void free_play_toserver_set_creative_slot(play_toserver_set_creative_slot packet) {
  free_slot(packet.item);
}

int walk_play_toserver_enchant_item(char * source, size_t max_len) {
  if(max_len < 2) return -1;
  return 2;
}

size_t size_play_toserver_enchant_item(play_toserver_enchant_item packet) {
  return 2;
}

char * dec_play_toserver_enchant_item(play_toserver_enchant_item *packet, char * source) {
  source = dec_byte(&packet->window_id, source);
  source = dec_byte(&packet->enchantment, source);
  return source;
}

char * enc_play_toserver_enchant_item(char * dest, play_toserver_enchant_item source) {
  dest = enc_byte(dest, source.window_id);
  dest = enc_byte(dest, source.enchantment);
  return dest;
}

int walk_play_toserver_update_sign(char * source, size_t max_len) {
  int ret, size = 0;
  if(max_len < 8) {
    return -1;
  }
  size += 8;
  source += 8;
  max_len -= 8;
  if((ret = walk_string(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if((ret = walk_string(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if((ret = walk_string(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if((ret = walk_string(source, max_len)) < 0) {
    return -1;
  }
  return size + ret;
}

size_t size_play_toserver_update_sign(play_toserver_update_sign packet) {
  size_t size = 0;
  size += 8;
  size += size_string(packet.text1);
  size += size_string(packet.text2);
  size += size_string(packet.text3);
  size += size_string(packet.text4);
  return size;
}

char * dec_play_toserver_update_sign(play_toserver_update_sign *packet, char * source) {
  source = dec_position(&packet->location, source);
  if(!(source = dec_string(&packet->text1, source))) return NULL;
  if(!(source = dec_string(&packet->text2, source))) return NULL;
  if(!(source = dec_string(&packet->text3, source))) return NULL;
  if(!(source = dec_string(&packet->text4, source))) return NULL;
  return source;
}

char * enc_play_toserver_update_sign(char * dest, play_toserver_update_sign source) {
  dest = enc_position(dest, source.location);
  dest = enc_string(dest, source.text1);
  dest = enc_string(dest, source.text2);
  dest = enc_string(dest, source.text3);
  dest = enc_string(dest, source.text4);
  return dest;
}

void free_play_toserver_update_sign(play_toserver_update_sign packet) {
  free_string(packet.text1);
  free_string(packet.text2);
  free_string(packet.text3);
  free_string(packet.text4);
}

int walk_play_toserver_abilities(char * source, size_t max_len) {
  if(max_len < 9) return -1;
  return 9;
}

size_t size_play_toserver_abilities(play_toserver_abilities packet) {
  return 9;
}

char * dec_play_toserver_abilities(play_toserver_abilities *packet, char * source) {
  source = dec_byte(&packet->flags, source);
  source = dec_bef32(&packet->flying_speed, source);
  source = dec_bef32(&packet->walking_speed, source);
  return source;
}

char * enc_play_toserver_abilities(char * dest, play_toserver_abilities source) {
  dest = enc_byte(dest, source.flags);
  dest = enc_bef32(dest, source.flying_speed);
  dest = enc_bef32(dest, source.walking_speed);
  return dest;
}

int walk_play_toserver_tab_complete(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_string(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if(max_len < 1) {
      return -1;
  }
  uint8_t block_opt;
  source = dec_byte(&block_opt, source);
  size += 1;
  max_len -= 1;
  if(block_opt) {
    if(max_len < 8) {
      return -1;
    }
    size += 8;
    source += 8;
    max_len -= 8;
  }
  return size;
}

size_t size_play_toserver_tab_complete(play_toserver_tab_complete packet) {
  size_t size = 0;
  size += size_string(packet.text);
  size += 1;
  if(packet.block.opt) {
    size += 8;
  }
  return size;
}

char * dec_play_toserver_tab_complete(play_toserver_tab_complete *packet, char * source) {
  if(!(source = dec_string(&packet->text, source))) return NULL;
  source = dec_byte(&packet->block.opt, source);
  if(packet->block.opt) {
    source = dec_position(&packet->block.val, source);
  }
  return source;
}

char * enc_play_toserver_tab_complete(char * dest, play_toserver_tab_complete source) {
  dest = enc_string(dest, source.text);
  dest = enc_byte(dest, source.block.opt);
  if(source.block.opt) {
    dest = enc_position(dest, source.block.val);
  }
  return dest;
}

void free_play_toserver_tab_complete(play_toserver_tab_complete packet) {
  free_string(packet.text);
}

int walk_play_toserver_settings(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_string(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if(max_len < 4) {
    return -1;
  }
  return size + 4;
}

size_t size_play_toserver_settings(play_toserver_settings packet) {
  size_t size = 0;
  size += size_string(packet.locale);
  return size + 4;
}

char * dec_play_toserver_settings(play_toserver_settings *packet, char * source) {
  if(!(source = dec_string(&packet->locale, source))) return NULL;
  source = dec_byte(&packet->view_distance, source);
  source = dec_byte(&packet->chat_flags, source);
  source = dec_byte(&packet->chat_colors, source);
  source = dec_byte(&packet->skin_parts, source);
  return source;
}

char * enc_play_toserver_settings(char * dest, play_toserver_settings source) {
  dest = enc_string(dest, source.locale);
  dest = enc_byte(dest, source.view_distance);
  dest = enc_byte(dest, source.chat_flags);
  dest = enc_byte(dest, source.chat_colors);
  dest = enc_byte(dest, source.skin_parts);
  return dest;
}

void free_play_toserver_settings(play_toserver_settings packet) {
  free_string(packet.locale);
}

int walk_play_toserver_client_command(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  return size + ret;
}

size_t size_play_toserver_client_command(play_toserver_client_command packet) {
  size_t size = 0;
  size += size_varlong(packet.payload);
  return size;
}

char * dec_play_toserver_client_command(play_toserver_client_command *packet, char * source) {
  source = dec_varlong(&packet->payload, source);
  return source;
}

char * enc_play_toserver_client_command(char * dest, play_toserver_client_command source) {
  dest = enc_varlong(dest, source.payload);
  return dest;
}

int walk_play_toserver_custom_payload(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_string(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  ret = max_len;
  return size + ret;
}

size_t size_play_toserver_custom_payload(play_toserver_custom_payload packet) {
  size_t size = 0;
  size += size_string(packet.channel);
  size += packet.data.len;
  return size;
}

char * dec_play_toserver_custom_payload(play_toserver_custom_payload *packet, char * source, size_t total_size) {
  char * endptr = source + total_size;
  if(!(source = dec_string(&packet->channel, source))) return NULL;
  source = dec_buffer(&packet->data, source, endptr - source);
  return source;
}

char * enc_play_toserver_custom_payload(char * dest, play_toserver_custom_payload source) {
  dest = enc_string(dest, source.channel);
  dest = enc_buffer(dest, source.data);
  return dest;
}

void free_play_toserver_custom_payload(play_toserver_custom_payload packet) {
  free_string(packet.channel);
  free(packet.data.base);
}

int walk_play_toserver_spectate(char * source, size_t max_len) {
  if(max_len < 16) return -1;
  return 16;
}

size_t size_play_toserver_spectate(play_toserver_spectate packet) {
  return 16;
}

char * dec_play_toserver_spectate(play_toserver_spectate *packet, char * source) {
  source = dec_uuid(&packet->target, source);
  return source;
}

char * enc_play_toserver_spectate(char * dest, play_toserver_spectate source) {
  dest = enc_uuid(dest, source.target);
  return dest;
}

int walk_play_toserver_resource_pack_receive(char * source, size_t max_len) {
  int ret, size = 0;
  if((ret = walk_string(source, max_len)) < 0) {
    return -1;
  }
  size += ret;
  source += ret;
  max_len -= ret;
  if((ret = walk_varlong(source, max_len)) < 0) {
    return -1;
  }
  return size + ret;
}

size_t size_play_toserver_resource_pack_receive(play_toserver_resource_pack_receive packet) {
  size_t size = 0;
  size += size_string(packet.hash);
  size += size_varlong(packet.result);
  return size;
}

char * dec_play_toserver_resource_pack_receive(play_toserver_resource_pack_receive *packet, char * source) {
  if(!(source = dec_string(&packet->hash, source))) return NULL;
  source = dec_varlong(&packet->result, source);
  return source;
}

char * enc_play_toserver_resource_pack_receive(char * dest, play_toserver_resource_pack_receive source) {
  dest = enc_string(dest, source.hash);
  dest = enc_varlong(dest, source.result);
  return dest;
}

void free_play_toserver_resource_pack_receive(play_toserver_resource_pack_receive packet) {
  free_string(packet.hash);
}

void * generic_toclient_decode(int state, int32_t id, char * src, size_t len) {
  void * dest;
  switch(state) {
    case status_id:
      switch(id) {
        case status_toclient_server_info_id:
          if(walk_status_toclient_server_info(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(status_toclient_server_info)))) return NULL;
          dec_status_toclient_server_info(dest, src);
          break;
        case status_toclient_ping_id:
          if(walk_status_toclient_ping(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(status_toclient_ping)))) return NULL;
          dec_status_toclient_ping(dest, src);
          break;
        default:
          return NULL;
      }
      break;
    case login_id:
      switch(id) {
        case login_toclient_disconnect_id:
          if(walk_login_toclient_disconnect(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(login_toclient_disconnect)))) return NULL;
          dec_login_toclient_disconnect(dest, src);
          break;
        case login_toclient_encryption_begin_id:
          if(walk_login_toclient_encryption_begin(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(login_toclient_encryption_begin)))) return NULL;
          dec_login_toclient_encryption_begin(dest, src);
          break;
        case login_toclient_success_id:
          if(walk_login_toclient_success(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(login_toclient_success)))) return NULL;
          dec_login_toclient_success(dest, src);
          break;
        case login_toclient_compress_id:
          if(walk_login_toclient_compress(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(login_toclient_compress)))) return NULL;
          dec_login_toclient_compress(dest, src);
          break;
        default:
          return NULL;
      }
      break;
    case play_id:
      switch(id) {
        case play_toclient_keep_alive_id:
          if(walk_play_toclient_keep_alive(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_keep_alive)))) return NULL;
          dec_play_toclient_keep_alive(dest, src);
          break;
        case play_toclient_login_id:
          if(walk_play_toclient_login(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_login)))) return NULL;
          dec_play_toclient_login(dest, src);
          break;
        case play_toclient_chat_id:
          if(walk_play_toclient_chat(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_chat)))) return NULL;
          dec_play_toclient_chat(dest, src);
          break;
        case play_toclient_update_time_id:
          if(walk_play_toclient_update_time(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_update_time)))) return NULL;
          dec_play_toclient_update_time(dest, src);
          break;
        case play_toclient_entity_equipment_id:
          if(walk_play_toclient_entity_equipment(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_entity_equipment)))) return NULL;
          dec_play_toclient_entity_equipment(dest, src);
          break;
        case play_toclient_spawn_position_id:
          if(walk_play_toclient_spawn_position(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_spawn_position)))) return NULL;
          dec_play_toclient_spawn_position(dest, src);
          break;
        case play_toclient_update_health_id:
          if(walk_play_toclient_update_health(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_update_health)))) return NULL;
          dec_play_toclient_update_health(dest, src);
          break;
        case play_toclient_respawn_id:
          if(walk_play_toclient_respawn(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_respawn)))) return NULL;
          dec_play_toclient_respawn(dest, src);
          break;
        case play_toclient_position_id:
          if(walk_play_toclient_position(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_position)))) return NULL;
          dec_play_toclient_position(dest, src);
          break;
        case play_toclient_held_item_slot_id:
          if(walk_play_toclient_held_item_slot(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_held_item_slot)))) return NULL;
          dec_play_toclient_held_item_slot(dest, src);
          break;
        case play_toclient_bed_id:
          if(walk_play_toclient_bed(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_bed)))) return NULL;
          dec_play_toclient_bed(dest, src);
          break;
        case play_toclient_animation_id:
          if(walk_play_toclient_animation(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_animation)))) return NULL;
          dec_play_toclient_animation(dest, src);
          break;
        case play_toclient_named_entity_spawn_id:
          if(walk_play_toclient_named_entity_spawn(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_named_entity_spawn)))) return NULL;
          dec_play_toclient_named_entity_spawn(dest, src);
          break;
        case play_toclient_collect_id:
          if(walk_play_toclient_collect(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_collect)))) return NULL;
          dec_play_toclient_collect(dest, src);
          break;
        case play_toclient_spawn_entity_id:
          if(walk_play_toclient_spawn_entity(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_spawn_entity)))) return NULL;
          dec_play_toclient_spawn_entity(dest, src);
          break;
        case play_toclient_spawn_entity_living_id:
          if(walk_play_toclient_spawn_entity_living(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_spawn_entity_living)))) return NULL;
          dec_play_toclient_spawn_entity_living(dest, src);
          break;
        case play_toclient_spawn_entity_painting_id:
          if(walk_play_toclient_spawn_entity_painting(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_spawn_entity_painting)))) return NULL;
          dec_play_toclient_spawn_entity_painting(dest, src);
          break;
        case play_toclient_spawn_entity_experience_orb_id:
          if(walk_play_toclient_spawn_entity_experience_orb(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_spawn_entity_experience_orb)))) return NULL;
          dec_play_toclient_spawn_entity_experience_orb(dest, src);
          break;
        case play_toclient_entity_velocity_id:
          if(walk_play_toclient_entity_velocity(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_entity_velocity)))) return NULL;
          dec_play_toclient_entity_velocity(dest, src);
          break;
        case play_toclient_entity_destroy_id:
          if(walk_play_toclient_entity_destroy(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_entity_destroy)))) return NULL;
          dec_play_toclient_entity_destroy(dest, src);
          break;
        case play_toclient_entity_id:
          if(walk_play_toclient_entity(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_entity)))) return NULL;
          dec_play_toclient_entity(dest, src);
          break;
        case play_toclient_rel_entity_move_id:
          if(walk_play_toclient_rel_entity_move(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_rel_entity_move)))) return NULL;
          dec_play_toclient_rel_entity_move(dest, src);
          break;
        case play_toclient_entity_look_id:
          if(walk_play_toclient_entity_look(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_entity_look)))) return NULL;
          dec_play_toclient_entity_look(dest, src);
          break;
        case play_toclient_entity_move_look_id:
          if(walk_play_toclient_entity_move_look(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_entity_move_look)))) return NULL;
          dec_play_toclient_entity_move_look(dest, src);
          break;
        case play_toclient_entity_teleport_id:
          if(walk_play_toclient_entity_teleport(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_entity_teleport)))) return NULL;
          dec_play_toclient_entity_teleport(dest, src);
          break;
        case play_toclient_entity_head_rotation_id:
          if(walk_play_toclient_entity_head_rotation(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_entity_head_rotation)))) return NULL;
          dec_play_toclient_entity_head_rotation(dest, src);
          break;
        case play_toclient_entity_status_id:
          if(walk_play_toclient_entity_status(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_entity_status)))) return NULL;
          dec_play_toclient_entity_status(dest, src);
          break;
        case play_toclient_attach_entity_id:
          if(walk_play_toclient_attach_entity(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_attach_entity)))) return NULL;
          dec_play_toclient_attach_entity(dest, src);
          break;
        case play_toclient_entity_metadata_id:
          if(walk_play_toclient_entity_metadata(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_entity_metadata)))) return NULL;
          dec_play_toclient_entity_metadata(dest, src);
          break;
        case play_toclient_entity_effect_id:
          if(walk_play_toclient_entity_effect(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_entity_effect)))) return NULL;
          dec_play_toclient_entity_effect(dest, src);
          break;
        case play_toclient_remove_entity_effect_id:
          if(walk_play_toclient_remove_entity_effect(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_remove_entity_effect)))) return NULL;
          dec_play_toclient_remove_entity_effect(dest, src);
          break;
        case play_toclient_experience_id:
          if(walk_play_toclient_experience(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_experience)))) return NULL;
          dec_play_toclient_experience(dest, src);
          break;
        case play_toclient_update_attributes_id:
          if(walk_play_toclient_update_attributes(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_update_attributes)))) return NULL;
          dec_play_toclient_update_attributes(dest, src);
          break;
        case play_toclient_map_chunk_id:
          if(walk_play_toclient_map_chunk(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_map_chunk)))) return NULL;
          dec_play_toclient_map_chunk(dest, src);
          break;
        case play_toclient_multi_block_change_id:
          if(walk_play_toclient_multi_block_change(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_multi_block_change)))) return NULL;
          dec_play_toclient_multi_block_change(dest, src);
          break;
        case play_toclient_block_change_id:
          if(walk_play_toclient_block_change(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_block_change)))) return NULL;
          dec_play_toclient_block_change(dest, src);
          break;
        case play_toclient_block_action_id:
          if(walk_play_toclient_block_action(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_block_action)))) return NULL;
          dec_play_toclient_block_action(dest, src);
          break;
        case play_toclient_block_break_animation_id:
          if(walk_play_toclient_block_break_animation(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_block_break_animation)))) return NULL;
          dec_play_toclient_block_break_animation(dest, src);
          break;
        case play_toclient_map_chunk_bulk_id:
          if(walk_play_toclient_map_chunk_bulk(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_map_chunk_bulk)))) return NULL;
          dec_play_toclient_map_chunk_bulk(dest, src, len);
          break;
        case play_toclient_explosion_id:
          if(walk_play_toclient_explosion(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_explosion)))) return NULL;
          dec_play_toclient_explosion(dest, src);
          break;
        case play_toclient_world_event_id:
          if(walk_play_toclient_world_event(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_world_event)))) return NULL;
          dec_play_toclient_world_event(dest, src);
          break;
        case play_toclient_named_sound_effect_id:
          if(walk_play_toclient_named_sound_effect(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_named_sound_effect)))) return NULL;
          dec_play_toclient_named_sound_effect(dest, src);
          break;
        case play_toclient_world_particles_id:
          if(walk_play_toclient_world_particles(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_world_particles)))) return NULL;
          dec_play_toclient_world_particles(dest, src);
          break;
        case play_toclient_game_state_change_id:
          if(walk_play_toclient_game_state_change(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_game_state_change)))) return NULL;
          dec_play_toclient_game_state_change(dest, src);
          break;
        case play_toclient_spawn_entity_weather_id:
          if(walk_play_toclient_spawn_entity_weather(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_spawn_entity_weather)))) return NULL;
          dec_play_toclient_spawn_entity_weather(dest, src);
          break;
        case play_toclient_open_window_id:
          if(walk_play_toclient_open_window(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_open_window)))) return NULL;
          dec_play_toclient_open_window(dest, src);
          break;
        case play_toclient_close_window_id:
          if(walk_play_toclient_close_window(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_close_window)))) return NULL;
          dec_play_toclient_close_window(dest, src);
          break;
        case play_toclient_set_slot_id:
          if(walk_play_toclient_set_slot(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_set_slot)))) return NULL;
          dec_play_toclient_set_slot(dest, src);
          break;
        case play_toclient_window_items_id:
          if(walk_play_toclient_window_items(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_window_items)))) return NULL;
          dec_play_toclient_window_items(dest, src);
          break;
        case play_toclient_craft_progress_bar_id:
          if(walk_play_toclient_craft_progress_bar(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_craft_progress_bar)))) return NULL;
          dec_play_toclient_craft_progress_bar(dest, src);
          break;
        case play_toclient_transaction_id:
          if(walk_play_toclient_transaction(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_transaction)))) return NULL;
          dec_play_toclient_transaction(dest, src);
          break;
        case play_toclient_update_sign_id:
          if(walk_play_toclient_update_sign(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_update_sign)))) return NULL;
          dec_play_toclient_update_sign(dest, src);
          break;
        case play_toclient_map_id:
          if(walk_play_toclient_map(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_map)))) return NULL;
          dec_play_toclient_map(dest, src);
          break;
        case play_toclient_tile_entity_data_id:
          if(walk_play_toclient_tile_entity_data(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_tile_entity_data)))) return NULL;
          dec_play_toclient_tile_entity_data(dest, src);
          break;
        case play_toclient_open_sign_entity_id:
          if(walk_play_toclient_open_sign_entity(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_open_sign_entity)))) return NULL;
          dec_play_toclient_open_sign_entity(dest, src);
          break;
        case play_toclient_statistics_id:
          if(walk_play_toclient_statistics(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_statistics)))) return NULL;
          dec_play_toclient_statistics(dest, src);
          break;
        case play_toclient_player_info_id:
          if(walk_play_toclient_player_info(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_player_info)))) return NULL;
          dec_play_toclient_player_info(dest, src);
          break;
        case play_toclient_abilities_id:
          if(walk_play_toclient_abilities(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_abilities)))) return NULL;
          dec_play_toclient_abilities(dest, src);
          break;
        case play_toclient_tab_complete_id:
          if(walk_play_toclient_tab_complete(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_tab_complete)))) return NULL;
          dec_play_toclient_tab_complete(dest, src);
          break;
        case play_toclient_scoreboard_objective_id:
          if(walk_play_toclient_scoreboard_objective(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_scoreboard_objective)))) return NULL;
          dec_play_toclient_scoreboard_objective(dest, src);
          break;
        case play_toclient_scoreboard_score_id:
          if(walk_play_toclient_scoreboard_score(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_scoreboard_score)))) return NULL;
          dec_play_toclient_scoreboard_score(dest, src);
          break;
        case play_toclient_scoreboard_display_objective_id:
          if(walk_play_toclient_scoreboard_display_objective(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_scoreboard_display_objective)))) return NULL;
          dec_play_toclient_scoreboard_display_objective(dest, src);
          break;
        case play_toclient_scoreboard_team_id:
          if(walk_play_toclient_scoreboard_team(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_scoreboard_team)))) return NULL;
          dec_play_toclient_scoreboard_team(dest, src);
          break;
        case play_toclient_custom_payload_id:
          if(walk_play_toclient_custom_payload(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_custom_payload)))) return NULL;
          dec_play_toclient_custom_payload(dest, src, len);
          break;
        case play_toclient_kick_disconnect_id:
          if(walk_play_toclient_kick_disconnect(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_kick_disconnect)))) return NULL;
          dec_play_toclient_kick_disconnect(dest, src);
          break;
        case play_toclient_difficulty_id:
          if(walk_play_toclient_difficulty(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_difficulty)))) return NULL;
          dec_play_toclient_difficulty(dest, src);
          break;
        case play_toclient_combat_event_id:
          if(walk_play_toclient_combat_event(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_combat_event)))) return NULL;
          dec_play_toclient_combat_event(dest, src);
          break;
        case play_toclient_camera_id:
          if(walk_play_toclient_camera(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_camera)))) return NULL;
          dec_play_toclient_camera(dest, src);
          break;
        case play_toclient_world_border_id:
          if(walk_play_toclient_world_border(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_world_border)))) return NULL;
          dec_play_toclient_world_border(dest, src);
          break;
        case play_toclient_title_id:
          if(walk_play_toclient_title(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_title)))) return NULL;
          dec_play_toclient_title(dest, src);
          break;
        case play_toclient_set_compression_id:
          if(walk_play_toclient_set_compression(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_set_compression)))) return NULL;
          dec_play_toclient_set_compression(dest, src);
          break;
        case play_toclient_playerlist_header_id:
          if(walk_play_toclient_playerlist_header(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_playerlist_header)))) return NULL;
          dec_play_toclient_playerlist_header(dest, src);
          break;
        case play_toclient_resource_pack_send_id:
          if(walk_play_toclient_resource_pack_send(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_resource_pack_send)))) return NULL;
          dec_play_toclient_resource_pack_send(dest, src);
          break;
        case play_toclient_update_entity_nbt_id:
          if(walk_play_toclient_update_entity_nbt(src, len) != len) return NULL;
          if(!(dest = malloc(sizeof(play_toclient_update_entity_nbt)))) return NULL;
          dec_play_toclient_update_entity_nbt(dest, src);
          break;
        default:
          return NULL;
      }
      break;
    default:
      return NULL;
  }
  return dest;
}
